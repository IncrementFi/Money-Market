{
  "ComptrollerAddress": "0xf8d6e0586b0a20c7",
  "ContractAddress": {
    "FUSD": "0xf8d6e0586b0a20c7",
    "FBTC": "0xf8d6e0586b0a20c7",
    "FETH": "0xf8d6e0586b0a20c7",
    "Kibble": "0xf8d6e0586b0a20c7",
    "Error": "0xf8d6e0586b0a20c7",
    "Interfaces": "0xf8d6e0586b0a20c7",
    "Config": "0xf8d6e0586b0a20c7",
    "TwoSegmentsInterestRateModel": "0xf8d6e0586b0a20c7",
    "ComptrollerV1": "0xf8d6e0586b0a20c7",
    "SimpleOracle": "0x01cf0e2f2f715450",
    "LendingPool_FUSD": "0x192440c99cb17282",
    "LendingPool_FlowToken": "0xfd43f9148d4b725d",
    "LendingPool_FBTC": "0xeb179c27144f783c",
    "LendingPool_FETH": "0x0f7025fa05b578e3",
    "FungibleToken": "0xee82856bf20e2aa6",
    "FlowToken": "0x0ae53cb6e3f42a79",
    "ChainAdmin": "0xf8d6e0586b0a20c7"
  },
  "PoolAddress": {
    "0x192440c99cb17282": {
      "PoolContract": "LendingPool_FUSD",
      "PoolName": "FUSD",
      "LowerPoolName": "fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "fusdBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0x192440c99cb17282"
    },
    "0xfd43f9148d4b725d": {
      "PoolContract": "LendingPool_FlowToken",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x0ae53cb6e3f42a79",
      "PoolAddress": "0xfd43f9148d4b725d"
    },
    "0xeb179c27144f783c": {
      "PoolContract": "LendingPool_FBTC",
      "PoolName": "FBTC",
      "LowerPoolName": "fBTC",
      "TokenName": "FBTC",
      "VaultBalancePath": "fBTCBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0xeb179c27144f783c"
    },
    "0x0f7025fa05b578e3": {
      "PoolContract": "LendingPool_FETH",
      "PoolName": "FETH",
      "LowerPoolName": "fETH",
      "TokenName": "FETH",
      "VaultBalancePath": "fETHBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0x0f7025fa05b578e3"
    }
  },
  "PoolName": {
    "FUSD": {
      "PoolContract": "LendingPool_FUSD",
      "PoolName": "FUSD",
      "LowerPoolName": "fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "fusdBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0x192440c99cb17282"
    },
    "FlowToken": {
      "PoolContract": "LendingPool_FlowToken",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x0ae53cb6e3f42a79",
      "PoolAddress": "0xfd43f9148d4b725d"
    },
    "FBTC": {
      "PoolContract": "LendingPool_FBTC",
      "PoolName": "FBTC",
      "LowerPoolName": "fBTC",
      "TokenName": "FBTC",
      "VaultBalancePath": "fBTCBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0xeb179c27144f783c"
    },
    "FETH": {
      "PoolContract": "LendingPool_FETH",
      "PoolName": "FETH",
      "LowerPoolName": "fETH",
      "TokenName": "FETH",
      "VaultBalancePath": "fETHBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0x0f7025fa05b578e3"
    }
  },
  "Codes": {
    "Scripts": {
      "QueryAllMarkets": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(comptrollerAddr: Address): [Address] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow() \n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let poolAddrs = comptrollerRef.getAllMarkets()\n    log(poolAddrs)\n    return poolAddrs\n}",
      "QueryMarketInfo": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow() \n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )    \n        )\n    let poolInfo = comptrollerRef.getMarketInfo(poolAddr: poolAddr)\n    log(poolInfo)\n    return poolInfo\n}",
      "QueryUserAllPools": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(userAddr: Address, comptrollerAddr: Address): [Address] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )    \n        )\n    let poolAddrs = comptrollerRef.getUserMarkets(userAddr: userAddr)\n    log(poolAddrs)\n    return poolAddrs\n}",
      "QueryUserPoolInfo": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\n\npub fun main(userAddr: Address, poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let userInfo = comptrollerRef.getUserMarketInfo(userAddr: userAddr, poolAddr: poolAddr)\n    \n    return userInfo\n}",
      "QueryUserPoolInfos": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\n\npub fun main(userAddr: Address, comptrollerAddr: Address): {Address: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )    \n        )\n    \n    var userInfos: {Address: AnyStruct} = {}\n    let poolAddrs = comptrollerRef.getUserMarkets(userAddr: userAddr)\n    for poolAddr in poolAddrs {\n        let userInfo = comptrollerRef.getUserMarketInfo(userAddr: userAddr, poolAddr: poolAddr)\n        userInfos.insert(key: poolAddr, userInfo)\n    }\n    return userInfos\n}",
      "QueryVaultBalance": "import FungibleToken from 0xee82856bf20e2aa6\n\npub fun main(userAddr: Address, vaultPath: PublicPath): UFix64 {\n    let vaultBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(vaultPath)\n    if vaultBalance.check() == false || vaultBalance.borrow() == nil {\n        log(0.0)\n        return 0.0\n    }\n    log(vaultBalance.borrow()!.balance)\n    return vaultBalance.borrow()!.balance\n}",
      "QueryUserPosition": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n// Return: (cross-market collateral value in usd; cross-market borrows in usd)\n// LTV ratio = ret[1] / ret[0]\npub fun main(userAddr: Address, comptrollerAddr: Address): [String; 2] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let res = comptrollerRef.getUserCrossMarketLiquidity(userAddr: userAddr)\n    return res\n}",
      "QueryMarketInterestRateModelParams": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(poolAddr: Address): {String: AnyStruct} {\n\n    let poolPublicCap = getAccount(poolAddr).getCapability<&{Interfaces.PoolPublic}>(Config.PoolPublicPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invalid pool capability.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY\n            )\n        )\n    let interestRateAddress = poolPublicCap.getInterestRateModelAddress()\n\n    let interestRateModelRef = getAccount(interestRateAddress)\n        .getCapability<&{Interfaces.InterestRateModelPublic}>(Config.InterestRateModelPublicPath)\n        .borrow() ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invalid interest rate model capability.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY\n            )\n        )\n    \n    return interestRateModelRef.getInterestRateModelParams()\n}",
      "QueryMarketBorrowers": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(comptrollerAddr: Address, poolAddr: Address, from: UInt64, to: UInt64): [Address] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow() \n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    if from == 0 && to == 0 {\n        return comptrollerRef.getPoolPublicRef(poolAddr: poolAddr).getPoolBorrowerList()\n    } else {\n        return comptrollerRef.getPoolPublicRef(poolAddr: poolAddr).getPoolBorrowerSlicedList(from: from, to: to)\n    }\n    \n}",
      "QuerySimpleOracleFeedLatestResult": "import Interfaces from 0xf8d6e0586b0a20c7\nimport SimpleOracle from 0x01cf0e2f2f715450\n\n// Return pool's underlying asset's latest data in [timestamp, priceData].\n// Return value of [0.0, 0.0] means the queried pool's underlying asset's data feed is not available.\npub fun main(oracle: Address, pool: Address): [UFix64; 2] {\n    let oracleGetterRef = getAccount(oracle)\n        .getCapability<&SimpleOracle.Oracle{Interfaces.OraclePublic}>(SimpleOracle.OraclePublicPath)\n        .borrow() ?? panic(\"Could not borrow reference to OracleGetter\")\n\n    return oracleGetterRef.latestResult(pool: pool)\n}\n "
    },
    "Transactions": {
      "Deposit": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\n\ntransaction(amountDeposit: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_fusd\")\n        log(\"Test deposit FUSD \".concat(amountDeposit.toString()))\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User vault :\".concat(self.fusdVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.fusdVault.withdraw(amount: amountDeposit)\n        LendingPool_FUSD.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n ",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\n\ntransaction(amountDeposit: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_flowToken\")\n        log(\"Test deposit FlowToken \".concat(amountDeposit.toString()))\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User vault :\".concat(self.flowTokenVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountDeposit)\n        LendingPool_FlowToken.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n ",
        "FBTC": "import FBTC from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FBTC from 0xeb179c27144f783c\n\ntransaction(amountDeposit: UFix64) {\n    let fBTCVault: &FBTC.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_fBTC\")\n        log(\"Test deposit FBTC \".concat(amountDeposit.toString()))\n\n        let fBTCStoragePath = /storage/fBTCVault\n        if (signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) == nil) {\n            log(\"Create new local fBTC vault\")\n            signer.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n        }\n        self.fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) ?? panic(\"cannot borrow reference to FBTC Vault\")\n        log(\"User vault :\".concat(self.fBTCVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.fBTCVault.withdraw(amount: amountDeposit)\n        LendingPool_FBTC.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left fBTC \".concat(self.fBTCVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n ",
        "FETH": "import FETH from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FETH from 0x0f7025fa05b578e3\n\ntransaction(amountDeposit: UFix64) {\n    let fETHVault: &FETH.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_fETH\")\n        log(\"Test deposit FETH \".concat(amountDeposit.toString()))\n\n        let fETHStoragePath = /storage/fETHVault\n        if (signer.borrow<&FETH.Vault>(from: fETHStoragePath) == nil) {\n            log(\"Create new local fETH vault\")\n            signer.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n        }\n        self.fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath) ?? panic(\"cannot borrow reference to FETH Vault\")\n        log(\"User vault :\".concat(self.fETHVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.fETHVault.withdraw(amount: amountDeposit)\n        LendingPool_FETH.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left fETH \".concat(self.fETHVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n "
      },
      "Redeem": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_fusd\")\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"User redeem fusd \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FUSD.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.fusdVault.deposit(from: <-redeemedVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_flowToken\")\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"User redeem flowToken \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FlowToken.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.flowTokenVault.deposit(from: <-redeemedVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FBTC": "import FBTC from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FBTC from 0xeb179c27144f783c\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let fBTCVault: &FBTC.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_fBTC\")\n\n        let fBTCStoragePath = /storage/fBTCVault\n        if (signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) == nil) {\n            log(\"Create new local fBTC vault\")\n            signer.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n        }\n        self.fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) ?? panic(\"cannot borrow reference to FBTC Vault\")\n        log(\"User left fBTC \".concat(self.fBTCVault.balance.toString()))\n        log(\"User redeem fBTC \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FBTC.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.fBTCVault.deposit(from: <-redeemedVault)\n\n        log(\"User left fBTC \".concat(self.fBTCVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FETH": "import FETH from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FETH from 0x0f7025fa05b578e3\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let fETHVault: &FETH.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_fETH\")\n\n        let fETHStoragePath = /storage/fETHVault\n        if (signer.borrow<&FETH.Vault>(from: fETHStoragePath) == nil) {\n            log(\"Create new local fETH vault\")\n            signer.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n        }\n        self.fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath) ?? panic(\"cannot borrow reference to FETH Vault\")\n        log(\"User left fETH \".concat(self.fETHVault.balance.toString()))\n        log(\"User redeem fETH \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FETH.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.fETHVault.deposit(from: <-redeemedVault)\n\n        log(\"User left fETH \".concat(self.fETHVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Borrow": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_fusd\")\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"User borrow fusd \".concat(amountBorrow.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_FUSD.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.fusdVault.deposit(from: <-borrowVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_flowToken\")\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"User borrow flowToken \".concat(amountBorrow.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_FlowToken.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.flowTokenVault.deposit(from: <-borrowVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FBTC": "import FBTC from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FBTC from 0xeb179c27144f783c\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let fBTCVault: &FBTC.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_fBTC\")\n\n        let fBTCStoragePath = /storage/fBTCVault\n        if (signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) == nil) {\n            log(\"Create new local fBTC vault\")\n            signer.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n        }\n        self.fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) ?? panic(\"cannot borrow reference to FBTC Vault\")\n        log(\"User left fBTC \".concat(self.fBTCVault.balance.toString()))\n        log(\"User borrow fBTC \".concat(amountBorrow.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_FBTC.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.fBTCVault.deposit(from: <-borrowVault)\n\n        log(\"User left fBTC \".concat(self.fBTCVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FETH": "import FETH from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FETH from 0x0f7025fa05b578e3\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let fETHVault: &FETH.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_fETH\")\n\n        let fETHStoragePath = /storage/fETHVault\n        if (signer.borrow<&FETH.Vault>(from: fETHStoragePath) == nil) {\n            log(\"Create new local fETH vault\")\n            signer.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n        }\n        self.fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath) ?? panic(\"cannot borrow reference to FETH Vault\")\n        log(\"User left fETH \".concat(self.fETHVault.balance.toString()))\n        log(\"User borrow fETH \".concat(amountBorrow.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_FETH.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.fETHVault.deposit(from: <-borrowVault)\n\n        log(\"User left fETH \".concat(self.fETHVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Repay": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_fusd\")\n        \n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_FUSD.accrueInterest()\n            let totalRepayScaled = LendingPool_FUSD.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = Config.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/Config.ufixScale\n        }\n        log(\"Test repay fusd \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.fusdVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FUSD.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.fusdVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_flowToken\")\n        \n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_FlowToken.accrueInterest()\n            let totalRepayScaled = LendingPool_FlowToken.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = Config.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/Config.ufixScale\n        }\n        log(\"Test repay flowToken \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FlowToken.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.flowTokenVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FBTC": "import FBTC from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FBTC from 0xeb179c27144f783c\nimport Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let fBTCVault: &FBTC.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_fBTC\")\n        \n        let fBTCStoragePath = /storage/fBTCVault\n        if (signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) == nil) {\n            log(\"Create new local fBTC vault\")\n            signer.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n        }\n        self.fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) ?? panic(\"cannot borrow reference to FBTC Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left fBTC \".concat(self.fBTCVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_FBTC.accrueInterest()\n            let totalRepayScaled = LendingPool_FBTC.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = Config.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/Config.ufixScale\n        }\n        log(\"Test repay fBTC \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.fBTCVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FBTC.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.fBTCVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left fBTC \".concat(self.fBTCVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FETH": "import FETH from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FETH from 0x0f7025fa05b578e3\nimport Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let fETHVault: &FETH.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_fETH\")\n        \n        let fETHStoragePath = /storage/fETHVault\n        if (signer.borrow<&FETH.Vault>(from: fETHStoragePath) == nil) {\n            log(\"Create new local fETH vault\")\n            signer.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n        }\n        self.fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath) ?? panic(\"cannot borrow reference to FETH Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left fETH \".concat(self.fETHVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_FETH.accrueInterest()\n            let totalRepayScaled = LendingPool_FETH.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = Config.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/Config.ufixScale\n        }\n        log(\"Test repay fETH \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.fETHVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FETH.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.fETHVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left fETH \".concat(self.fETHVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Test": {
        "NextBlock": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\ntransaction() {\n\n    prepare(signer: AuthAccount) {\n        log(\"Next block --------------- pre block id: \".concat(getCurrentBlock().height.toString()))\n        let poolAddrs = signer.getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()!.getAllMarkets()\n        for poolAddr in poolAddrs {\n            getAccount(poolAddr).getCapability<&{Interfaces.PoolPublic}>(Config.PoolPublicPublicPath).borrow()!.accrueInterest()\n        }\n        log(\"End ---------------------- aft block id: \".concat(getCurrentBlock().height.toString()))\n    }\n\n    execute {\n    }\n}",
        "MintFUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(mintAmount: UFix64) {\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start ---------------\")\n        log(\"user add fusd\".concat(mintAmount.toString()))\n        let fusdStoragePath = /storage/fusdVault\n        var fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath)\n        if fusdVault == nil {\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath)\n        fusdVault!.deposit(from: <-FUSD.test_minter.mintTokens(amount: mintAmount))\n        log(\"End -----------------------------\")\n    }\n\n    execute {\n    }\n}\n",
        "MintFBTC": "import FBTC from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(mintAmount: UFix64) {\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start ---------------\")\n        log(\"user add fBTC\".concat(mintAmount.toString()))\n        let fBTCStoragePath = /storage/fBTCVault\n        var fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath)\n        if fBTCVault == nil {\n            signer.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\n            signer.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n        }\n        fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath)\n        fBTCVault!.deposit(from: <-FBTC.test_minter.mintTokens(amount: mintAmount))\n        log(\"End -----------------------------\")\n    }\n\n    execute {\n    }\n}\n",
        "MintFETH": "import FETH from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(mintAmount: UFix64) {\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start ---------------\")\n        log(\"user add fETH\".concat(mintAmount.toString()))\n        let fETHStoragePath = /storage/fETHVault\n        var fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath)\n        if fETHVault == nil {\n            signer.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\n            signer.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n        }\n        fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath)\n        fETHVault!.deposit(from: <-FETH.test_minter.mintTokens(amount: mintAmount))\n        log(\"End -----------------------------\")\n    }\n\n    execute {\n    }\n}\n",
        "MintFlowToken": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\n\ntransaction(to: Address, amount: UFix64) {\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- emulator_flow_transfer\")\n\n        log(\"account deposit FlowToken\".concat(amount.toString()))\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n          ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n        // Withdraw tokens from the signer's stored vault\n        let sentVault <- vaultRef.withdraw(amount: amount)\n\n        // Get a reference to the recipient's Receiver\n        let receiverRef =  getAccount(to)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow<&{FungibleToken.Receiver}>()\n            ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n        // Deposit the withdrawn tokens in the recipient's receiver\n        receiverRef.deposit(from: <-sentVault)\n\n        log(\"End -----------------------------\")\n    }\n\n    execute {\n    }\n}\n"
      }
    }
  },
  "Pools": [
    {
      "vaultBalancePath": "fusdBalance",
      "poolName": "FUSD",
      "tokenName": "FUSD",
      "marketAddress": "0x192440c99cb17282",
      "tokenAddress": "0xf8d6e0586b0a20c7"
    },
    {
      "vaultBalancePath": "flowTokenBalance",
      "poolName": "FlowToken",
      "tokenName": "Flow",
      "marketAddress": "0xfd43f9148d4b725d",
      "tokenAddress": "0x0ae53cb6e3f42a79"
    },
    {
      "vaultBalancePath": "fBTCBalance",
      "poolName": "FBTC",
      "tokenName": "FBTC",
      "marketAddress": "0xeb179c27144f783c",
      "tokenAddress": "0xf8d6e0586b0a20c7"
    },
    {
      "vaultBalancePath": "fETHBalance",
      "poolName": "FETH",
      "tokenName": "FETH",
      "marketAddress": "0x0f7025fa05b578e3",
      "tokenAddress": "0xf8d6e0586b0a20c7"
    }
  ]
}