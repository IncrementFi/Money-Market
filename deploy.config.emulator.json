{
  "ComptrollerAddress": "0xf8d6e0586b0a20c7",
  "ContractAddress": {
    "FUSD": "0xf8d6e0586b0a20c7",
    "LendingError": "0xf8d6e0586b0a20c7",
    "LendingInterfaces": "0xf8d6e0586b0a20c7",
    "LendingConfig": "0xf8d6e0586b0a20c7",
    "TwoSegmentsInterestRateModel": "0xf8d6e0586b0a20c7",
    "LendingComptroller": "0xf8d6e0586b0a20c7",
    "BLT": "0xf8d6e0586b0a20c7",
    "SimpleOracle": "0x01cf0e2f2f715450",
    "LendingPool_FUSD": "0x192440c99cb17282",
    "LendingPool_FlowToken": "0xfd43f9148d4b725d",
    "LendingPool_BLT": "0xeb179c27144f783c",
    "FungibleToken": "0xee82856bf20e2aa6",
    "FlowToken": "0x0ae53cb6e3f42a79",
    "ChainAdmin": "0xf8d6e0586b0a20c7"
  },
  "PoolAddress": {
    "0x192440c99cb17282": {
      "PoolContract": "LendingPool_FUSD",
      "PoolName": "FUSD",
      "LowerPoolName": "fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "fusdBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0x192440c99cb17282"
    },
    "0xfd43f9148d4b725d": {
      "PoolContract": "LendingPool_FlowToken",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x0ae53cb6e3f42a79",
      "PoolAddress": "0xfd43f9148d4b725d"
    },
    "0xeb179c27144f783c": {
      "PoolContract": "LendingPool_BLT",
      "PoolName": "BLT",
      "LowerPoolName": "bLT",
      "TokenName": "BLT",
      "VaultBalancePath": "bLTBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0xeb179c27144f783c"
    }
  },
  "PoolName": {
    "FUSD": {
      "PoolContract": "LendingPool_FUSD",
      "PoolName": "FUSD",
      "LowerPoolName": "fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "fusdBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0x192440c99cb17282"
    },
    "FlowToken": {
      "PoolContract": "LendingPool_FlowToken",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x0ae53cb6e3f42a79",
      "PoolAddress": "0xfd43f9148d4b725d"
    },
    "BLT": {
      "PoolContract": "LendingPool_BLT",
      "PoolName": "BLT",
      "LowerPoolName": "bLT",
      "TokenName": "BLT",
      "VaultBalancePath": "bLTBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0xeb179c27144f783c"
    }
  },
  "Codes": {
    "Scripts": {
      "QueryAllMarkets": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n\npub fun main(comptrollerAddr: Address): [Address] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow() \n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let poolAddrs = comptrollerRef.getAllMarkets()\n    return poolAddrs\n}",
      "QueryMarketInfo": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n\npub fun main(poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow() \n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )    \n        )\n    let poolInfo = comptrollerRef.getMarketInfo(poolAddr: poolAddr)\n    return poolInfo\n}",
      "QueryMarketInfos": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n\npub fun main(comptrollerAddr: Address): {Address: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow() \n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let poolAddrs = comptrollerRef.getAllMarkets()\n\n    var poolInfos: {Address: AnyStruct} = {}\n    for poolAddr in poolAddrs {\n        let poolInfo = comptrollerRef.getMarketInfo(poolAddr: poolAddr)\n        poolInfos.insert(key: poolAddr, poolInfo)\n    }\n    \n    return poolInfos\n}",
      "QueryUserAllPools": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n\npub fun main(userAddr: Address, comptrollerAddr: Address): [Address] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow()\n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )    \n        )\n    let poolAddrs = comptrollerRef.getUserMarkets(userAddr: userAddr)\n    \n    return poolAddrs\n}",
      "QueryUserPoolInfo": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n\n\npub fun main(userAddr: Address, poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow()\n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let userInfo = comptrollerRef.getUserMarketInfo(userAddr: userAddr, poolAddr: poolAddr)\n    \n    return userInfo\n}",
      "QueryUserPoolInfos": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n\n\npub fun main(userAddr: Address, comptrollerAddr: Address): {Address: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow()\n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )    \n        )\n    \n    var userInfos: {Address: AnyStruct} = {}\n    let poolAddrs = comptrollerRef.getUserMarkets(userAddr: userAddr)\n    for poolAddr in poolAddrs {\n        let userInfo = comptrollerRef.getUserMarketInfo(userAddr: userAddr, poolAddr: poolAddr)\n        userInfos.insert(key: poolAddr, userInfo)\n    }\n    return userInfos\n}",
      "QueryVaultBalance": "import FungibleToken from 0xee82856bf20e2aa6\n\npub fun main(userAddr: Address, vaultPath: PublicPath): UFix64 {\n    let vaultBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(vaultPath)\n    if vaultBalance.check() == false || vaultBalance.borrow() == nil {\n        log(0.0)\n        return 0.0\n    }\n    return vaultBalance.borrow()!.balance\n}",
      "QueryUserPosition": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n// Return: (cross-market collateral value in usd; cross-market borrows in usd)\n// LTV ratio = ret[1] / ret[0]\npub fun main(userAddr: Address, comptrollerAddr: Address): [String; 3] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow()\n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let res = comptrollerRef.getUserCrossMarketLiquidity(userAddr: userAddr)\n    return res\n}",
      "QueryMarketInterestRateModelParams": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n\npub fun main(poolAddr: Address): {String: AnyStruct} {\n\n    let poolPublicCap = getAccount(poolAddr).getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath).borrow()\n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invalid pool capability.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY\n            )\n        )\n    let interestRateAddress = poolPublicCap.getInterestRateModelAddress()\n\n    let interestRateModelRef = getAccount(interestRateAddress)\n        .getCapability<&{LendingInterfaces.InterestRateModelPublic}>(LendingConfig.InterestRateModelPublicPath)\n        .borrow() ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invalid interest rate model capability.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY\n            )\n        )\n    \n    return interestRateModelRef.getInterestRateModelParams()\n}",
      "QueryMarketBorrowers": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingError from 0xf8d6e0586b0a20c7\n\npub fun main(comptrollerAddr: Address, poolAddr: Address, from: UInt64, to: UInt64): [Address] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow() \n        ?? panic(\n            LendingError.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: LendingError.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    if from == 0 && to == 0 {\n        return comptrollerRef.getPoolPublicRef(poolAddr: poolAddr).getPoolBorrowerList()\n    } else {\n        return comptrollerRef.getPoolPublicRef(poolAddr: poolAddr).getPoolBorrowerSlicedList(from: from, to: to)\n    }\n    \n}",
      "QuerySimpleOracleFeedLatestResult": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport SimpleOracle from 0x01cf0e2f2f715450\n\n/// Return pool's underlying asset's latest data in [timestamp, priceData].\n/// Return value of [0.0, 0.0] means the queried pool's underlying asset's data feed is not available.\npub fun main(oracle: Address, pool: Address): [UFix64; 2] {\n    let oracleGetterRef = getAccount(oracle)\n        .getCapability<&SimpleOracle.Oracle{LendingInterfaces.OraclePublic}>(SimpleOracle.OraclePublicPath)\n        .borrow() ?? panic(\"Could not borrow reference to OracleGetter\")\n\n    return oracleGetterRef.latestResult(pool: pool)\n}\n "
    },
    "Transactions": {
      "Deposit": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\n\ntransaction(amountDeposit: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_fusd\")\n        log(\"Test deposit FUSD \".concat(amountDeposit.toString()))\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User vault :\".concat(self.fusdVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.fusdVault.withdraw(amount: amountDeposit)\n        LendingPool_FUSD.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n ",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\n\ntransaction(amountDeposit: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_flowToken\")\n        log(\"Test deposit FlowToken \".concat(amountDeposit.toString()))\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User vault :\".concat(self.flowTokenVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountDeposit)\n        LendingPool_FlowToken.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n ",
        "BLT": "import BLT from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_BLT from 0xeb179c27144f783c\n\ntransaction(amountDeposit: UFix64) {\n    let bLTVault: &BLT.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_bLT\")\n        log(\"Test deposit BLT \".concat(amountDeposit.toString()))\n\n        let bLTStoragePath = /storage/bLTVault\n        if (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\n            log(\"Create new local bLT vault\")\n            signer.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n        }\n        self.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\n        log(\"User vault :\".concat(self.bLTVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.bLTVault.withdraw(amount: amountDeposit)\n        LendingPool_BLT.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n "
      },
      "Redeem": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_fusd\")\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"User redeem fusd \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n            \n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FUSD.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.fusdVault.deposit(from: <-redeemedVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_flowToken\")\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"User redeem flowToken \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n            \n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FlowToken.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.flowTokenVault.deposit(from: <-redeemedVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "BLT": "import BLT from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_BLT from 0xeb179c27144f783c\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let bLTVault: &BLT.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_bLT\")\n\n        let bLTStoragePath = /storage/bLTVault\n        if (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\n            log(\"Create new local bLT vault\")\n            signer.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n        }\n        self.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n        log(\"User redeem bLT \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n            \n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_BLT.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.bLTVault.deposit(from: <-redeemedVault)\n\n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "RedeemAll": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    let fusdVault: &FUSD.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_fusd\")\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n\n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FUSD.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: UFix64.max)\n        self.fusdVault.deposit(from: <-redeemedVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    let flowTokenVault: &FlowToken.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_flowToken\")\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n\n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FlowToken.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: UFix64.max)\n        self.flowTokenVault.deposit(from: <-redeemedVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "BLT": "import BLT from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_BLT from 0xeb179c27144f783c\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    let bLTVault: &BLT.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_bLT\")\n\n        let bLTStoragePath = /storage/bLTVault\n        if (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\n            log(\"Create new local bLT vault\")\n            signer.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n        }\n        self.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n\n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_BLT.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: UFix64.max)\n        self.bLTVault.deposit(from: <-redeemedVault)\n\n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Borrow": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_fusd\")\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n            \n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_FUSD.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.fusdVault.deposit(from: <-borrowVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_flowToken\")\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n            \n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_FlowToken.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.flowTokenVault.deposit(from: <-borrowVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "BLT": "import BLT from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_BLT from 0xeb179c27144f783c\nimport LendingComptroller from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let bLTVault: &BLT.Vault\n    let userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_bLT\")\n\n        let bLTStoragePath = /storage/bLTVault\n        if (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\n            signer.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n        }\n        self.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.UserCertificateStoragePath) == nil) {\n            destroy <-signer.load<@AnyResource>(from: LendingConfig.UserCertificateStoragePath)\n            \n            let userCertificate <- LendingComptroller.IssueUserCertificate()\n            signer.save(<-userCertificate, to: LendingConfig.UserCertificateStoragePath)\n            signer.link<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath, target: LendingConfig.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(LendingConfig.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_BLT.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.bLTVault.deposit(from: <-borrowVault)\n\n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Repay": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_fusd\")\n        \n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_FUSD.accrueInterest()\n            let totalRepayScaled = LendingPool_FUSD.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = LendingConfig.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/LendingConfig.ufixScale\n        }\n        log(\"Test repay fusd \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.fusdVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FUSD.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.fusdVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_flowToken\")\n        \n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_FlowToken.accrueInterest()\n            let totalRepayScaled = LendingPool_FlowToken.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = LendingConfig.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/LendingConfig.ufixScale\n        }\n        log(\"Test repay flowToken \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FlowToken.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.flowTokenVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "BLT": "import BLT from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_BLT from 0xeb179c27144f783c\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let bLTVault: &BLT.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_bLT\")\n        \n        let bLTStoragePath = /storage/bLTVault\n        if (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\n            log(\"Create new local bLT vault\")\n            signer.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n        }\n        self.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_BLT.accrueInterest()\n            let totalRepayScaled = LendingPool_BLT.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = LendingConfig.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/LendingConfig.ufixScale\n        }\n        log(\"Test repay bLT \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.bLTVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_BLT.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.bLTVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "RepayAll": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    let fusdVault: &FUSD.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_fusd\")\n        \n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n    }\n\n    execute {\n        // accrueInterest() to update with latest pool states used to calculate borrowBalance\n        LendingPool_FUSD.accrueInterest()\n        let totalRepayScaled = LendingPool_FUSD.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n        var amountRepay = LendingConfig.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/LendingConfig.ufixScale\n\n        let inUnderlyingVault <- self.fusdVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FUSD.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.fusdVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    let flowTokenVault: &FlowToken.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_flowToken\")\n        \n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n    }\n\n    execute {\n        // accrueInterest() to update with latest pool states used to calculate borrowBalance\n        LendingPool_FlowToken.accrueInterest()\n        let totalRepayScaled = LendingPool_FlowToken.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n        var amountRepay = LendingConfig.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/LendingConfig.ufixScale\n\n        let inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FlowToken.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.flowTokenVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "BLT": "import BLT from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_BLT from 0xeb179c27144f783c\nimport LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\n\ntransaction() {\n    let bLTVault: &BLT.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_bLT\")\n        \n        let bLTStoragePath = /storage/bLTVault\n        if (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\n            log(\"Create new local bLT vault\")\n            signer.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n        }\n        self.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n    }\n\n    execute {\n        // accrueInterest() to update with latest pool states used to calculate borrowBalance\n        LendingPool_BLT.accrueInterest()\n        let totalRepayScaled = LendingPool_BLT.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n        var amountRepay = LendingConfig.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/LendingConfig.ufixScale\n\n        let inUnderlyingVault <- self.bLTVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_BLT.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.bLTVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left bLT \".concat(self.bLTVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Liquidate": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\n\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\n    let fusdVault: &FUSD.Vault\n    let liquidatorAddr: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- liquidate_fusd_pool\")\n        log(\"Test liquidate FUSD \".concat(amountLiquidate.toString()))\n\n        let fusdStoragePath = /storage/fusdVault\n        \n        self.fusdVault  = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"liquidator's vault \".concat(self.fusdVault.balance.toString()))\n        self.liquidatorAddr = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.fusdVault.withdraw(amount: amountLiquidate)\n        let leftVault <- LendingPool_FUSD.liquidate(\n            liquidator: self.liquidatorAddr,\n            borrower: borrower,\n            poolCollateralizedToSeize: seizePoolAddr,\n            repayUnderlyingVault: <-inUnderlyingVault\n        )\n        if leftVault != nil {\n            self.fusdVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n\n        log(\"End -----------------------------\")\n    }\n}\n ",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\n\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\n    let flowTokenVault: &FlowToken.Vault\n    let liquidatorAddr: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- liquidate_flowToken_pool\")\n        log(\"Test liquidate FlowToken \".concat(amountLiquidate.toString()))\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        \n        self.flowTokenVault  = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"liquidator's vault \".concat(self.flowTokenVault.balance.toString()))\n        self.liquidatorAddr = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountLiquidate)\n        let leftVault <- LendingPool_FlowToken.liquidate(\n            liquidator: self.liquidatorAddr,\n            borrower: borrower,\n            poolCollateralizedToSeize: seizePoolAddr,\n            repayUnderlyingVault: <-inUnderlyingVault\n        )\n        if leftVault != nil {\n            self.flowTokenVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n\n        log(\"End -----------------------------\")\n    }\n}\n ",
        "BLT": "import BLT from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_BLT from 0xeb179c27144f783c\n\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\n    let bLTVault: &BLT.Vault\n    let liquidatorAddr: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- liquidate_bLT_pool\")\n        log(\"Test liquidate BLT \".concat(amountLiquidate.toString()))\n\n        let bLTStoragePath = /storage/bLTVault\n        \n        self.bLTVault  = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\n        log(\"liquidator's vault \".concat(self.bLTVault.balance.toString()))\n        self.liquidatorAddr = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.bLTVault.withdraw(amount: amountLiquidate)\n        let leftVault <- LendingPool_BLT.liquidate(\n            liquidator: self.liquidatorAddr,\n            borrower: borrower,\n            poolCollateralizedToSeize: seizePoolAddr,\n            repayUnderlyingVault: <-inUnderlyingVault\n        )\n        if leftVault != nil {\n            self.bLTVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n\n        log(\"End -----------------------------\")\n    }\n}\n "
      },
      "Test": {
        "NextBlock": "import LendingInterfaces from 0xf8d6e0586b0a20c7\nimport LendingConfig from 0xf8d6e0586b0a20c7\ntransaction() {\n\n    prepare(signer: AuthAccount) {\n        log(\"Next block --------------- pre block id: \".concat(getCurrentBlock().height.toString()))\n        let poolAddrs = signer.getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.ComptrollerPublicPath).borrow()!.getAllMarkets()\n        for poolAddr in poolAddrs {\n            getAccount(poolAddr).getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.PoolPublicPublicPath).borrow()!.accrueInterest()\n        }\n        log(\"End ---------------------- aft block id: \".concat(getCurrentBlock().height.toString()))\n    }\n\n    execute {\n    }\n}",
        "MintFUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(mintAmount: UFix64) {\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start ---------------\")\n        log(\"user add fusd\".concat(mintAmount.toString()))\n        let fusdStoragePath = /storage/fusdVault\n        var fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath)\n        if fusdVault == nil {\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath)\n        fusdVault!.deposit(from: <-FUSD.test_minter.mintTokens(amount: mintAmount))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "MintBLT": "import BLT from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(mintAmount: UFix64) {\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start ---------------\")\n        log(\"user add bLT\".concat(mintAmount.toString()))\n        let bLTStoragePath = /storage/bLTVault\n        var bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath)\n        if bLTVault == nil {\n            signer.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n        }\n        bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath)\n        bLTVault!.deposit(from: <-BLT.test_minter.mintTokens(amount: mintAmount))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "MintAll": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport BLT from 0xf8d6e0586b0a20c7\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\n\n        log(\"Transaction Start ---------------\")\n        log(\"user add fusd\".concat(mintAmount.toString()))\n        let fusdStoragePath = /storage/fusdVault\n        var fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath)\n        if fusdVault == nil {\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath)\n        fusdVault!.deposit(from: <-FUSD.test_minter.mintTokens(amount: mintAmount))\n        log(\"End -----------------------------\")\n    \n        log(\"Transaction Start ---------------\")\n        log(\"user add bLT\".concat(mintAmount.toString()))\n        let bLTStoragePath = /storage/bLTVault\n        var bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath)\n        if bLTVault == nil {\n            signer.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\n            signer.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n        }\n        bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath)\n        bLTVault!.deposit(from: <-BLT.test_minter.mintTokens(amount: mintAmount))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "MintFlowToken": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\n\ntransaction(to: Address, amount: UFix64) {\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- emulator_flow_transfer\")\n\n        log(\"account deposit FlowToken\".concat(amount.toString()))\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n          ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n        // Withdraw tokens from the signer's stored vault\n        let sentVault <- vaultRef.withdraw(amount: amount)\n\n        // Get a reference to the recipient's Receiver\n        let receiverRef =  getAccount(to)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow<&{FungibleToken.Receiver}>()\n            ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n        // Deposit the withdrawn tokens in the recipient's receiver\n        receiverRef.deposit(from: <-sentVault)\n\n        log(\"End -----------------------------\")\n    }\n\n    execute {\n    }\n}\n"
      }
    }
  },
  "Pools": [
    {
      "vaultBalancePath": "fusdBalance",
      "poolName": "FUSD",
      "tokenName": "FUSD",
      "marketAddress": "0x192440c99cb17282",
      "tokenAddress": "0xf8d6e0586b0a20c7"
    },
    {
      "vaultBalancePath": "flowTokenBalance",
      "poolName": "FlowToken",
      "tokenName": "Flow",
      "marketAddress": "0xfd43f9148d4b725d",
      "tokenAddress": "0x0ae53cb6e3f42a79"
    },
    {
      "vaultBalancePath": "bLTBalance",
      "poolName": "BLT",
      "tokenName": "BLT",
      "marketAddress": "0xeb179c27144f783c",
      "tokenAddress": "0xf8d6e0586b0a20c7"
    }
  ]
}