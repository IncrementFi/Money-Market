{
  "ComptrollerAddress": "0xf8d6e0586b0a20c7",
  "ContractAddress": {
    "FUSD": "0xf8d6e0586b0a20c7",
    "Kibble": "0xf8d6e0586b0a20c7",
    "Error": "0xf8d6e0586b0a20c7",
    "Interfaces": "0xf8d6e0586b0a20c7",
    "Config": "0xf8d6e0586b0a20c7",
    "TwoSegmentsInterestRateModel": "0xf8d6e0586b0a20c7",
    "ComptrollerV1": "0xf8d6e0586b0a20c7",
    "SimpleOracle": "0x01cf0e2f2f715450",
    "LendingPool_FUSD": "0x192440c99cb17282",
    "LendingPool_FlowToken": "0xfd43f9148d4b725d",
    "FungibleToken": "0xee82856bf20e2aa6",
    "FlowToken": "0x0ae53cb6e3f42a79",
    "ChainAdmin": "0xf8d6e0586b0a20c7"
  },
  "PoolAddress": {
    "0x192440c99cb17282": {
      "PoolContract": "LendingPool_FUSD",
      "PoolName": "FUSD",
      "LowerPoolName": "fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "fusdBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0x192440c99cb17282"
    },
    "0xfd43f9148d4b725d": {
      "PoolContract": "LendingPool_FlowToken",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x0ae53cb6e3f42a79",
      "PoolAddress": "0xfd43f9148d4b725d"
    }
  },
  "PoolName": {
    "FUSD": {
      "PoolContract": "LendingPool_FUSD",
      "PoolName": "FUSD",
      "LowerPoolName": "fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "fusdBalance",
      "TokenAddress": "0xf8d6e0586b0a20c7",
      "PoolAddress": "0x192440c99cb17282"
    },
    "FlowToken": {
      "PoolContract": "LendingPool_FlowToken",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x0ae53cb6e3f42a79",
      "PoolAddress": "0xfd43f9148d4b725d"
    }
  },
  "Codes": {
    "Scripts": {
      "QueryAllMarkets": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(comptrollerAddr: Address): [Address] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow() \n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let poolAddrs = comptrollerRef.getAllMarkets()\n    log(poolAddrs)\n    return poolAddrs\n}",
      "QueryMarketInfo": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow() \n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )    \n        )\n    let poolInfo = comptrollerRef.getMarketInfo(poolAddr: poolAddr)\n    log(poolInfo)\n    return poolInfo\n}",
      "QueryUserAllPools": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(userAddr: Address, comptrollerAddr: Address): [Address] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )    \n        )\n    let poolAddrs = comptrollerRef.getUserMarkets(userAddr: userAddr)\n    log(poolAddrs)\n    return poolAddrs\n}",
      "QueryUserPoolInfo": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\n\npub fun main(userAddr: Address, poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let userInfo = comptrollerRef.getUserMarketInfo(userAddr: userAddr, poolAddr: poolAddr)\n    \n    return userInfo\n}",
      "QueryVaultBalance": "import FungibleToken from 0xee82856bf20e2aa6\n\npub fun main(userAddr: Address, vaultPath: PublicPath): UFix64 {\n    let vaultBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(vaultPath)\n    if vaultBalance.check() == false || vaultBalance.borrow() == nil {\n        log(0.0)\n        return 0.0\n    }\n    log(vaultBalance.borrow()!.balance)\n    return vaultBalance.borrow()!.balance\n}",
      "QueryUserPosition": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n// Return: (cross-market collateral value in usd; cross-market borrows in usd)\n// LTV ratio = ret[1] / ret[0]\npub fun main(userAddr: Address, comptrollerAddr: Address): [String; 2] {\n    let comptrollerRef = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invailid comptroller cap.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_COMPTROLLER_PUBLIC_CAPABILITY\n            )\n        )\n    let res = comptrollerRef.getUserCrossMarketLiquidity(userAddr: userAddr)\n    return res\n}",
      "QueryMarketInterestRateModelParams": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Error from 0xf8d6e0586b0a20c7\n\npub fun main(poolAddr: Address): {String: AnyStruct} {\n\n    let poolPublicCap = getAccount(poolAddr).getCapability<&{Interfaces.PoolPublic}>(Config.PoolPublicPublicPath).borrow()\n        ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invalid pool capability.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_POOL_PUBLIC_CAPABILITY\n            )\n        )\n    let interestRateAddress = poolPublicCap.getInterestRateModelAddress()\n\n    let interestRateModelRef = getAccount(interestRateAddress)\n        .getCapability<&{Interfaces.InterestRateModelPublic}>(Config.InterestRateModelPublicPath)\n        .borrow() ?? panic(\n            Error.ErrorEncode (\n                msg: \"Invalid interest rate model capability.\",\n                err: Error.ErrorCode.CANNOT_ACCESS_INTEREST_RATE_MODEL_CAPABILITY\n            )\n        )\n    \n    return interestRateModelRef.getInterestRateModelParams()\n}"
    },
    "Transactions": {
      "Deposit": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\n\ntransaction(amountDeposit: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_fusd\")\n        log(\"Test deposit FUSD \".concat(amountDeposit.toString()))\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User vault :\".concat(self.fusdVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.fusdVault.withdraw(amount: amountDeposit)\n        LendingPool_FUSD.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n ",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\n\ntransaction(amountDeposit: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let supplierAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_deposit_flowToken\")\n        log(\"Test deposit FlowToken \".concat(amountDeposit.toString()))\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User vault :\".concat(self.flowTokenVault.balance.toString()))\n        self.supplierAddress = signer.address\n    }\n\n    execute {\n        let inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountDeposit)\n        LendingPool_FlowToken.supply(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n "
      },
      "Redeem": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_fusd\")\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"User redeem fusd \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FUSD.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.fusdVault.deposit(from: <-redeemedVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\ntransaction(amountUnderlyingToRedeem: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_redeem_flowToken\")\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"User redeem flowToken \".concat(amountUnderlyingToRedeem.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let redeemedVault <- LendingPool_FlowToken.redeemUnderlying(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: amountUnderlyingToRedeem)\n        self.flowTokenVault.deposit(from: <-redeemedVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Borrow": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_fusd\")\n\n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"User borrow fusd \".concat(amountBorrow.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_FUSD.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.fusdVault.deposit(from: <-borrowVault)\n\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport ComptrollerV1 from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\nimport Interfaces from 0xf8d6e0586b0a20c7\n\n\ntransaction(amountBorrow: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_borrow_flowToken\")\n\n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"User borrow flowToken \".concat(amountBorrow.toString()))\n\n        // Get protocol-issued user certificate\n        if (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.UserCertificateStoragePath) == nil) {\n            let userCertificate <- ComptrollerV1.IssueUserCertificate()\n            signer.save(<-userCertificate, to: Config.UserCertificateStoragePath)\n            signer.link<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath, target: Config.UserCertificateStoragePath)\n        }\n        self.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.UserCertificatePrivatePath)\n    }\n\n    execute {\n        let borrowVault <- LendingPool_FlowToken.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\n        self.flowTokenVault.deposit(from: <-borrowVault)\n\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Repay": {
        "FUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FUSD from 0x192440c99cb17282\nimport Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let fusdVault: &FUSD.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_fusd\")\n        \n        let fusdStoragePath = /storage/fusdVault\n        if (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\n            log(\"Create new local fusd vault\")\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        self.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_FUSD.accrueInterest()\n            let totalRepayScaled = LendingPool_FUSD.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = Config.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/Config.ufixScale\n        }\n        log(\"Test repay fusd \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.fusdVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FUSD.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.fusdVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left fusd \".concat(self.fusdVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n",
        "FlowToken": "import FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport LendingPool_FlowToken from 0xfd43f9148d4b725d\nimport Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\n\ntransaction(amount: UFix64) {\n    let flowTokenVault: &FlowToken.Vault\n    let borrowerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- user_repay_flowToken\")\n        \n        let flowTokenStoragePath = /storage/flowTokenVault\n        if (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\n            log(\"Create new local flowToken vault\")\n            signer.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\n            signer.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n        }\n        self.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\n        self.borrowerAddress = signer.address\n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n    }\n\n    execute {\n        var amountRepay = amount\n        if amountRepay == UFix64.max {\n            // accrueInterest() to update with latest pool states used to calculate borrowBalance\n            LendingPool_FlowToken.accrueInterest()\n            let totalRepayScaled = LendingPool_FlowToken.borrowBalanceSnapshotScaled(borrowerAddress: self.borrowerAddress)\n            amountRepay = Config.ScaledUInt256ToUFix64(totalRepayScaled) + 1.0/Config.ufixScale\n        }\n        log(\"Test repay flowToken \".concat(amountRepay.toString()))\n\n        let inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountRepay)\n        let leftVault <- LendingPool_FlowToken.repayBorrow(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\n        if leftVault != nil {\n            self.flowTokenVault.deposit(from: <-leftVault!)\n        } else {\n            destroy leftVault\n        }\n        \n        log(\"User left flowToken \".concat(self.flowTokenVault.balance.toString()))\n        log(\"End -----------------------------\")\n    }\n}\n"
      },
      "Test": {
        "NextBlock": "import Interfaces from 0xf8d6e0586b0a20c7\nimport Config from 0xf8d6e0586b0a20c7\ntransaction() {\n\n    prepare(signer: AuthAccount) {\n        log(\"Next block --------------- pre block id: \".concat(getCurrentBlock().height.toString()))\n        let poolAddrs = signer.getCapability<&{Interfaces.ComptrollerPublic}>(Config.ComptrollerPublicPath).borrow()!.getAllMarkets()\n        for poolAddr in poolAddrs {\n            getAccount(poolAddr).getCapability<&{Interfaces.PoolPublic}>(Config.PoolPublicPublicPath).borrow()!.accrueInterest()\n        }\n        log(\"End ---------------------- aft block id: \".concat(getCurrentBlock().height.toString()))\n    }\n\n    execute {\n    }\n}",
        "MintFUSD": "import FUSD from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\n\ntransaction(mintAmount: UFix64) {\n\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start ---------------\")\n        log(\"user add fusd\".concat(mintAmount.toString()))\n        let fusdStoragePath = /storage/fusdVault\n        var fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath)\n        if fusdVault == nil {\n            signer.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\n            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n        }\n        fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath)\n        fusdVault!.deposit(from: <-FUSD.test_minter.mintTokens(amount: mintAmount))\n        log(\"End -----------------------------\")\n    }\n\n    execute {\n    }\n}\n",
        "MintFlowToken": "import FungibleToken from 0xee82856bf20e2aa6\nimport FlowToken from 0x0ae53cb6e3f42a79\n\n\ntransaction(to: Address, amount: UFix64) {\n    prepare(signer: AuthAccount) {\n        log(\"Transaction Start --------------- emulator_flow_transfer\")\n\n        log(\"account deposit FlowToken\".concat(amount.toString()))\n        // Get a reference to the signer's stored vault\n        let vaultRef = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n          ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n        // Withdraw tokens from the signer's stored vault\n        let sentVault <- vaultRef.withdraw(amount: amount)\n\n        // Get a reference to the recipient's Receiver\n        let receiverRef =  getAccount(to)\n            .getCapability(/public/flowTokenReceiver)\n            .borrow<&{FungibleToken.Receiver}>()\n            ?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n        // Deposit the withdrawn tokens in the recipient's receiver\n        receiverRef.deposit(from: <-sentVault)\n\n        log(\"End -----------------------------\")\n    }\n\n    execute {\n    }\n}\n"
      }
    }
  }
}