{
  "ComptrollerAddress": "0x67e2455e98098a95",
  "ContractAddress": {
    "Config": "0xbef33bc3b8b3e500",
    "Error": "0xbef33bc3b8b3e500",
    "Interfaces": "0xbef33bc3b8b3e500",
    "ComptrollerV1": "0x67e2455e98098a95",
    "SimpleOracle": "0xb9ea46f9e5fc5504",
    "FungibleToken": "0x9a0766d93b6608b7",
    "FlowToken": "0x7e60df042a9c0868",
    "FUSD": "0xe223d8a629e49c68",
    "FBTC": "0x92d6cfec0152a767",
    "FETH": "0x9c69e4392b968bd4"
  },
  "PoolAddress": {
    "0xe87fbdc31260d121": {
      "PoolContract": "LendingPool",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x7e60df042a9c0868",
      "PoolAddress": "0xe87fbdc31260d121",
      "Fake": false
    },
    "0xf8110b49279777d0": {
      "PoolContract": "LendingPool",
      "PoolName": "FUSD",
      "LowerPoolName": "fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "fusdBalance",
      "TokenAddress": "0xe223d8a629e49c68",
      "PoolAddress": "0xf8110b49279777d0",
      "Fake": false
    },
    "0x80c056e9db4e71db": {
      "PoolContract": "LendingPool",
      "PoolName": "FBTC",
      "LowerPoolName": "fBTC",
      "TokenName": "FBTC",
      "VaultBalancePath": "fBTCBalance",
      "TokenAddress": "0x92d6cfec0152a767",
      "PoolAddress": "0x80c056e9db4e71db",
      "Fake": true
    },
    "0x63f87ade5fd1e732": {
      "PoolContract": "LendingPool",
      "PoolName": "FETH",
      "LowerPoolName": "fETH",
      "TokenName": "FETH",
      "VaultBalancePath": "fETHBalance",
      "TokenAddress": "0x9c69e4392b968bd4",
      "PoolAddress": "0x63f87ade5fd1e732",
      "Fake": true
    }
  },
  "Codes": {
    "Scripts": {
      "QueryAllMarkets": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(comptrollerAddr: Address): [Address] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet poolAddrs = edRldmmilnjgib.mndlleMmmAndj()\nreturn poolAddrs\n}",
      "QueryMarketInfo": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet poolInfo = edRldmmilnjgib.iehIndlleMndj(poolAddr: poolAddr)\nreturn poolInfo\n}",
      "QueryUserAllPools": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(userAddr: Address, comptrollerAddr: Address): [Address] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet poolAddrs = edRldmmilnjgib.mndlleMldmUndj(userAddr: userAddr)\nreturn poolAddrs\n}",
      "QueryUserPoolInfo": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(userAddr: Address, poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet userInfo = edRldmmilnjgib.iehIndlleMldmUndj(userAddr: userAddr, poolAddr: poolAddr)\nreturn userInfo\n}",
      "QueryVaultBalance": "import FungibleToken from 0x9a0766d93b6608b7\npub fun main(userAddr: Address, vaultPath: PublicPath): UFix64 {\nlet vaultBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(vaultPath)\nif vaultBalance.check() == false || vaultBalance.borrow() == nil {\nreturn 0.0\n}\nreturn vaultBalance.borrow()!.balance\n}",
      "QueryUserPosition": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(userAddr: Address, comptrollerAddr: Address): [String; 2] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet res = edRldmmilnjgib.wnxcxtkxLndlleMmmilCldmUndj(userAddr: userAddr)\nreturn res\n}",
      "QueryMarketInterestRateModelParams": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(poolAddr: Address): {String: AnyStruct} {\nlet jeCbxmitPmiij = getAccount(poolAddr).getCapability<&{Interfaces.PoolPublic}>(Config.wnePbxmitPbxmitPmiiP).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invalid pool capability.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_LOOP_SSECCA_TONNAC\n)\n)\nlet interestRateAddress = jeCbxmitPmiij.mmdlccAmdciMdneRnmdldnhIndj()\nlet interestRateModelRef = getAccount(interestRateAddress)\n.getCapability<&{Interfaces.InterestRateModelPublic}>(Config.wnePbxmitPmdciMdneRnmdldnhI)\n.borrow() ?? panic(\nError.dcibhElillE (\nmsg: \"Invalid interest rate model capability.\",\nerr: Error.dciClillE.YTILIBAPAC_LEDOM_ETAR_TSERETNI_SSECCA_TONNAC\n)\n)\nreturn interestRateModelRef.mgelePmdciMdneRnmdldnhIndj()\n}",
      "GetSimpleOracleFeedLatestResult": "import Interfaces from 0xbef33bc3b8b3e500\nimport SimpleOracle from 0xb9ea46f9e5fc5504\npub fun main(oracle: Address, pool: Address): [UFix64; 2] {\nlet oracleGetterRef = getAccount(oracle)\n.getCapability<&SimpleOracle.Oracle{Interfaces.OraclePublic}>(SimpleOracle.wnePbxmitPdmbelO)\n.borrow() ?? panic(\"Could not borrow reference to OracleGetter\")\nreturn oracleGetterRef.nmtmdRnmdnem(pool: pool)\n}"
    },
    "Transactions": {
      "Deposit": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\ntransaction(amountDeposit: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountDeposit)\nLendingPool.wmjjtm(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\ntransaction(amountDeposit: UFix64) {\nlet fusdVault: &FUSD.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nif (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n}\nself.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.fusdVault.withdraw(amount: amountDeposit)\nLendingPool.wmjjtm(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}",
        "FBTC": "import FBTC from 0x92d6cfec0152a767\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\ntransaction(amountDeposit: UFix64) {\nlet fBTCVault: &FBTC.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet fBTCStoragePath = /storage/fBTCVault\nif (signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) == nil) {\nsigner.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n}\nself.fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) ?? panic(\"cannot borrow reference to FBTC Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.fBTCVault.withdraw(amount: amountDeposit)\nLendingPool.wmjjtm(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}",
        "FETH": "import FETH from 0x9c69e4392b968bd4\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x63f87ade5fd1e732\ntransaction(amountDeposit: UFix64) {\nlet fETHVault: &FETH.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet fETHStoragePath = /storage/fETHVault\nif (signer.borrow<&FETH.Vault>(from: fETHStoragePath) == nil) {\nsigner.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n}\nself.fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath) ?? panic(\"cannot borrow reference to FETH Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.fETHVault.withdraw(amount: amountDeposit)\nLendingPool.wmjjtm(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}"
      },
      "Redeem": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(gddcdRiTjhxwmldchUnhtige: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet redeemedVault <- LendingPool.jhxwmldchUgddcdl(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: gddcdRiTjhxwmldchUnhtige)\nself.flowTokenVault.deposit(from: <-redeemedVault)\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(gddcdRiTjhxwmldchUnhtige: UFix64) {\nlet fusdVault: &FUSD.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nif (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n}\nself.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet redeemedVault <- LendingPool.jhxwmldchUgddcdl(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: gddcdRiTjhxwmldchUnhtige)\nself.fusdVault.deposit(from: <-redeemedVault)\n}\n}",
        "FBTC": "import FBTC from 0x92d6cfec0152a767\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(gddcdRiTjhxwmldchUnhtige: UFix64) {\nlet fBTCVault: &FBTC.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet fBTCStoragePath = /storage/fBTCVault\nif (signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) == nil) {\nsigner.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n}\nself.fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) ?? panic(\"cannot borrow reference to FBTC Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet redeemedVault <- LendingPool.jhxwmldchUgddcdl(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: gddcdRiTjhxwmldchUnhtige)\nself.fBTCVault.deposit(from: <-redeemedVault)\n}\n}",
        "FETH": "import FETH from 0x9c69e4392b968bd4\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x63f87ade5fd1e732\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(gddcdRiTjhxwmldchUnhtige: UFix64) {\nlet fETHVault: &FETH.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet fETHStoragePath = /storage/fETHVault\nif (signer.borrow<&FETH.Vault>(from: fETHStoragePath) == nil) {\nsigner.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n}\nself.fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath) ?? panic(\"cannot borrow reference to FETH Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet redeemedVault <- LendingPool.jhxwmldchUgddcdl(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: gddcdRiTjhxwmldchUnhtige)\nself.fETHVault.deposit(from: <-redeemedVault)\n}\n}"
      },
      "Borrow": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(amountBorrow: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.flowTokenVault.deposit(from: <-borrowVault)\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(amountBorrow: UFix64) {\nlet fusdVault: &FUSD.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nif (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n}\nself.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.fusdVault.deposit(from: <-borrowVault)\n}\n}",
        "FBTC": "import FBTC from 0x92d6cfec0152a767\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(amountBorrow: UFix64) {\nlet fBTCVault: &FBTC.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet fBTCStoragePath = /storage/fBTCVault\nif (signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) == nil) {\nsigner.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n}\nself.fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) ?? panic(\"cannot borrow reference to FBTC Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.fBTCVault.deposit(from: <-borrowVault)\n}\n}",
        "FETH": "import FETH from 0x9c69e4392b968bd4\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x63f87ade5fd1e732\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(amountBorrow: UFix64) {\nlet fETHVault: &FETH.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet fETHStoragePath = /storage/fETHVault\nif (signer.borrow<&FETH.Vault>(from: fETHStoragePath) == nil) {\nsigner.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n}\nself.fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath) ?? panic(\"cannot borrow reference to FETH Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.fETHVault.deposit(from: <-borrowVault)\n}\n}"
      },
      "Repay": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\nimport Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction(amount: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.nmdldnhIdtlbbe()\nlet totalRepayScaled = LendingPool.cdmebSniwmjehSdbhemeBaillii(borrowerAddress: self.borrowerAddress)\namountRepay = Config.djvxFUiTjebnhIUcdmebS(totalRepayScaled) + 1.0/Config.dmebSvxet\n}\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.ailliBwejdl(ldaillii: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.flowTokenVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\nimport Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction(amount: UFix64) {\nlet fusdVault: &FUSD.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nif (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n}\nself.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.nmdldnhIdtlbbe()\nlet totalRepayScaled = LendingPool.cdmebSniwmjehSdbhemeBaillii(borrowerAddress: self.borrowerAddress)\namountRepay = Config.djvxFUiTjebnhIUcdmebS(totalRepayScaled) + 1.0/Config.dmebSvxet\n}\nlet inUnderlyingVault <- self.fusdVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.ailliBwejdl(ldaillii: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.fusdVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "FBTC": "import FBTC from 0x92d6cfec0152a767\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\nimport Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction(amount: UFix64) {\nlet fBTCVault: &FBTC.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet fBTCStoragePath = /storage/fBTCVault\nif (signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) == nil) {\nsigner.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n}\nself.fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath) ?? panic(\"cannot borrow reference to FBTC Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.nmdldnhIdtlbbe()\nlet totalRepayScaled = LendingPool.cdmebSniwmjehSdbhemeBaillii(borrowerAddress: self.borrowerAddress)\namountRepay = Config.djvxFUiTjebnhIUcdmebS(totalRepayScaled) + 1.0/Config.dmebSvxet\n}\nlet inUnderlyingVault <- self.fBTCVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.ailliBwejdl(ldaillii: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.fBTCVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "FETH": "import FETH from 0x9c69e4392b968bd4\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x63f87ade5fd1e732\nimport Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction(amount: UFix64) {\nlet fETHVault: &FETH.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet fETHStoragePath = /storage/fETHVault\nif (signer.borrow<&FETH.Vault>(from: fETHStoragePath) == nil) {\nsigner.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n}\nself.fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath) ?? panic(\"cannot borrow reference to FETH Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.nmdldnhIdtlbbe()\nlet totalRepayScaled = LendingPool.cdmebSniwmjehSdbhemeBaillii(borrowerAddress: self.borrowerAddress)\namountRepay = Config.djvxFUiTjebnhIUcdmebS(totalRepayScaled) + 1.0/Config.dmebSvxet\n}\nlet inUnderlyingVault <- self.fETHVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.ailliBwejdl(ldaillii: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.fETHVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}"
      },
      "SimpleOracle": {
        "UpdaterUploadFeedData": "import SimpleOracle from 0xb9ea46f9e5fc5504\ntransaction(mmdlccAmiij: Address, enec: UFix64) {\nprepare(updater: AuthAccount) {\nlet updaterRef = updater\n.borrow<&SimpleOracle.OracleUpdateProxy>(from: SimpleOracle.wnePdjelinSldnecjU)\n?? panic(\"Could not borrow reference to updater proxy\")\nupdaterRef.dnecjt(pool: mmdlccAmiij, enec: enec)\n}\n}"
      },
      "Test": {
        "NextBlock": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction() {\nprepare(signer: AuthAccount) {\nlet poolAddrs = signer.getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()!.mndlleMmmAndj()\nfor poolAddr in poolAddrs {\ngetAccount(poolAddr).getCapability<&{Interfaces.PoolPublic}>(Config.wnePbxmitPbxmitPmiiP).borrow()!.nmdldnhIdtlbbe()\n}\n}\nexecute {\n}\n}",
        "MintFBTC": "import FBTC from 0x92d6cfec0152a767\nimport FungibleToken from 0x9a0766d93b6608b7\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\nlet fBTCStoragePath = /storage/fBTCVault\nvar fBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath)\nif fBTCVault == nil {\nsigner.save(<-FBTC.createEmptyVault(), to: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Receiver}>(/public/fBTCReceiver, target: fBTCStoragePath)\nsigner.link<&FBTC.Vault{FungibleToken.Balance}>(/public/fBTCBalance, target: fBTCStoragePath)\n}\nfBTCVault = signer.borrow<&FBTC.Vault>(from: fBTCStoragePath)\nfBTCVault!.deposit(from: <-FBTC.test_minter.mintTokens(amount: mintAmount))\n}\nexecute {\n}\n}",
        "MintFETH": "import FETH from 0x9c69e4392b968bd4\nimport FungibleToken from 0x9a0766d93b6608b7\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\nlet fETHStoragePath = /storage/fETHVault\nvar fETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath)\nif fETHVault == nil {\nsigner.save(<-FETH.createEmptyVault(), to: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Receiver}>(/public/fETHReceiver, target: fETHStoragePath)\nsigner.link<&FETH.Vault{FungibleToken.Balance}>(/public/fETHBalance, target: fETHStoragePath)\n}\nfETHVault = signer.borrow<&FETH.Vault>(from: fETHStoragePath)\nfETHVault!.deposit(from: <-FETH.test_minter.mintTokens(amount: mintAmount))\n}\nexecute {\n}\n}"
      }
    }
  },
  "Pools": [
    {
      "vaultBalancePath": "flowTokenBalance",
      "poolName": "FlowToken",
      "tokenName": "Flow",
      "marketAddress": "0xe87fbdc31260d121",
      "tokenAddress": "0x7e60df042a9c0868"
    },
    {
      "vaultBalancePath": "fusdBalance",
      "poolName": "FUSD",
      "tokenName": "FUSD",
      "marketAddress": "0xf8110b49279777d0",
      "tokenAddress": "0xe223d8a629e49c68"
    },
    {
      "vaultBalancePath": "fBTCBalance",
      "poolName": "FBTC",
      "tokenName": "FBTC",
      "marketAddress": "0x80c056e9db4e71db",
      "tokenAddress": "0x92d6cfec0152a767"
    },
    {
      "vaultBalancePath": "fETHBalance",
      "poolName": "FETH",
      "tokenName": "FETH",
      "marketAddress": "0x63f87ade5fd1e732",
      "tokenAddress": "0x9c69e4392b968bd4"
    }
  ]
}