{
  "ComptrollerAddress": "0x67e2455e98098a95",
  "ContractAddress": {
    "Config": "0xbef33bc3b8b3e500",
    "Error": "0xbef33bc3b8b3e500",
    "Interfaces": "0xbef33bc3b8b3e500",
    "ComptrollerV1": "0x67e2455e98098a95",
    "SimpleOracle": "0xb9ea46f9e5fc5504",
    "FungibleToken": "0x9a0766d93b6608b7",
    "FlowToken": "0x7e60df042a9c0868",
    "FUSD": "0xe223d8a629e49c68",
    "BLT": "0x48adb192e4b081b0"
  },
  "PoolAddress": {
    "0xe87fbdc31260d121": {
      "PoolContract": "LendingPool",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x7e60df042a9c0868",
      "PoolAddress": "0xe87fbdc31260d121",
      "Fake": false
    },
    "0xf8110b49279777d0": {
      "PoolContract": "LendingPool",
      "PoolName": "FUSD",
      "LowerPoolName": "fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "fusdBalance",
      "TokenAddress": "0xe223d8a629e49c68",
      "PoolAddress": "0xf8110b49279777d0",
      "Fake": false
    },
    "0x80c056e9db4e71db": {
      "PoolContract": "LendingPool",
      "PoolName": "BLT",
      "LowerPoolName": "bLT",
      "TokenName": "BLT",
      "VaultBalancePath": "bLTBalance",
      "TokenAddress": "0x48adb192e4b081b0",
      "PoolAddress": "0x80c056e9db4e71db",
      "Fake": true
    }
  },
  "Codes": {
    "Scripts": {
      "QueryAllMarkets": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(comptrollerAddr: Address): [Address] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet poolAddrs = edRldmmilnjgib.mndlleMmmAndj()\nreturn poolAddrs\n}",
      "QueryMarketInfo": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet poolInfo = edRldmmilnjgib.iehIndlleMndj(poolAddr: poolAddr)\nreturn poolInfo\n}",
      "QueryMarketInfos": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(comptrollerAddr: Address): {Address: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet poolAddrs = edRldmmilnjgib.mndlleMmmAndj()\nvar poolInfos: {Address: AnyStruct} = {}\nfor poolAddr in poolAddrs {\nlet poolInfo = edRldmmilnjgib.iehIndlleMndj(poolAddr: poolAddr)\npoolInfos.insert(key: poolAddr, poolInfo)\n}\nreturn poolInfos\n}",
      "QueryUserAllPools": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(userAddr: Address, comptrollerAddr: Address): [Address] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet poolAddrs = edRldmmilnjgib.mndlleMldmUndj(userAddr: userAddr)\nreturn poolAddrs\n}",
      "QueryUserPoolInfo": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(userAddr: Address, poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet userInfo = edRldmmilnjgib.iehIndlleMldmUndj(userAddr: userAddr, poolAddr: poolAddr)\nreturn userInfo\n}",
      "QueryUserPoolInfos": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(userAddr: Address, comptrollerAddr: Address): {Address: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nvar userInfos: {Address: AnyStruct} = {}\nlet poolAddrs = edRldmmilnjgib.mndlleMldmUndj(userAddr: userAddr)\nfor poolAddr in poolAddrs {\nlet userInfo = edRldmmilnjgib.iehIndlleMldmUndj(userAddr: userAddr, poolAddr: poolAddr)\nuserInfos.insert(key: poolAddr, userInfo)\n}\nreturn userInfos\n}",
      "QueryVaultBalance": "import FungibleToken from 0x9a0766d93b6608b7\npub fun main(userAddr: Address, vaultPath: PublicPath): UFix64 {\nlet vaultBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(vaultPath)\nif vaultBalance.check() == false || vaultBalance.borrow() == nil {\nreturn 0.0\n}\nreturn vaultBalance.borrow()!.balance\n}",
      "QueryUserPosition": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(userAddr: Address, comptrollerAddr: Address): [String; 3] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nlet res = edRldmmilnjgib.wnxcxtkxLndlleMmmilCldmUndj(userAddr: userAddr)\nreturn res\n}",
      "QueryMarketInterestRateModelParams": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(poolAddr: Address): {String: AnyStruct} {\nlet jeCbxmitPmiij = getAccount(poolAddr).getCapability<&{Interfaces.PoolPublic}>(Config.wnePbxmitPbxmitPmiiP).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invalid pool capability.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_LOOP_SSECCA_TONNAC\n)\n)\nlet interestRateAddress = jeCbxmitPmiij.mmdlccAmdciMdneRnmdldnhIndj()\nlet interestRateModelRef = getAccount(interestRateAddress)\n.getCapability<&{Interfaces.InterestRateModelPublic}>(Config.wnePbxmitPmdciMdneRnmdldnhI)\n.borrow() ?? panic(\nError.dcibhElillE (\nmsg: \"Invalid interest rate model capability.\",\nerr: Error.dciClillE.YTILIBAPAC_LEDOM_ETAR_TSERETNI_SSECCA_TONNAC\n)\n)\nreturn interestRateModelRef.mgelePmdciMdneRnmdldnhIndj()\n}",
      "QueryMarketBorrowers": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\nimport Error from 0xbef33bc3b8b3e500\npub fun main(comptrollerAddr: Address, poolAddr: Address, from: UInt64, to: UInt64): [Address] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()\n?? panic(\nError.dcibhElillE (\nmsg: \"Invailid comptroller cap.\",\nerr: Error.dciClillE.YTILIBAPAC_CILBUP_RELLORTPMOC_SSECCA_TONNAC\n)\n)\nif from == 0 && to == 0 {\nreturn edRldmmilnjgib.edRbxmitPmiiPndj(poolAddr: poolAddr).nmxLldailliBmiiPndj()\n} else {\nreturn edRldmmilnjgib.edRbxmitPmiiPndj(poolAddr: poolAddr).nmxLcdbxmSldailliBmiiPndj(from: from, to: to)\n}\n}",
      "QuerySimpleOracleFeedLatestResult": "import Interfaces from 0xbef33bc3b8b3e500\nimport SimpleOracle from 0xb9ea46f9e5fc5504\npub fun main(oracle: Address, pool: Address): [UFix64; 2] {\nlet oracleGetterRef = getAccount(oracle)\n.getCapability<&SimpleOracle.Oracle{Interfaces.OraclePublic}>(SimpleOracle.wnePbxmitPdmbelO)\n.borrow() ?? panic(\"Could not borrow reference to OracleGetter\")\nreturn oracleGetterRef.nmtmdRnmdnem(pool: pool)\n}"
    },
    "Transactions": {
      "Deposit": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\ntransaction(amountDeposit: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountDeposit)\nLendingPool.wmjjtm(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\ntransaction(amountDeposit: UFix64) {\nlet fusdVault: &FUSD.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nif (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n}\nself.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.fusdVault.withdraw(amount: amountDeposit)\nLendingPool.wmjjtm(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\ntransaction(amountDeposit: UFix64) {\nlet bLTVault: &BLT.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet bLTStoragePath = /storage/bLTVault\nif (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n}\nself.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.bLTVault.withdraw(amount: amountDeposit)\nLendingPool.wmjjtm(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}"
      },
      "Redeem": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(gddcdRiTjhxwmldchUnhtige: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet redeemedVault <- LendingPool.jhxwmldchUgddcdl(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: gddcdRiTjhxwmldchUnhtige)\nself.flowTokenVault.deposit(from: <-redeemedVault)\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(gddcdRiTjhxwmldchUnhtige: UFix64) {\nlet fusdVault: &FUSD.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nif (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n}\nself.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet redeemedVault <- LendingPool.jhxwmldchUgddcdl(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: gddcdRiTjhxwmldchUnhtige)\nself.fusdVault.deposit(from: <-redeemedVault)\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(gddcdRiTjhxwmldchUnhtige: UFix64) {\nlet bLTVault: &BLT.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet bLTStoragePath = /storage/bLTVault\nif (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n}\nself.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet redeemedVault <- LendingPool.jhxwmldchUgddcdl(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: gddcdRiTjhxwmldchUnhtige)\nself.bLTVault.deposit(from: <-redeemedVault)\n}\n}"
      },
      "Borrow": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(amountBorrow: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.flowTokenVault.deposit(from: <-borrowVault)\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(amountBorrow: UFix64) {\nlet fusdVault: &FUSD.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nif (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n}\nself.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.fusdVault.deposit(from: <-borrowVault)\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\nimport ComptrollerV1 from 0x67e2455e98098a95\nimport Config from 0xbef33bc3b8b3e500\nimport Interfaces from 0xbef33bc3b8b3e500\ntransaction(amountBorrow: UFix64) {\nlet bLTVault: &BLT.Vault\nlet userCertificateCap: Capability<&{Interfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet bLTStoragePath = /storage/bLTVault\nif (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n}\nself.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nif (signer.borrow<&{Interfaces.IdentityCertificate}>(from: Config.wnePdjelinSdnebxexnldCldmU) == nil) {\nlet userCertificate <- ComptrollerV1.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: Config.wnePdjelinSdnebxexnldCldmU)\nsigner.link<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU, target: Config.wnePdjelinSdnebxexnldCldmU)\n}\nself.userCertificateCap = signer.getCapability<&{Interfaces.IdentityCertificate}>(Config.wnePdneuxlPdnebxexnldCldmU)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.bLTVault.deposit(from: <-borrowVault)\n}\n}"
      },
      "Repay": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\nimport Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction(amount: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.nmdldnhIdtlbbe()\nlet totalRepayScaled = LendingPool.cdmebSniwmjehSdbhemeBaillii(borrowerAddress: self.borrowerAddress)\namountRepay = Config.djvxFUiTjebnhIUcdmebS(totalRepayScaled) + 1.0/Config.dmebSvxet\n}\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.ailliBwejdl(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.flowTokenVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\nimport Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction(amount: UFix64) {\nlet fusdVault: &FUSD.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nif (signer.borrow<&FUSD.Vault>(from: fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: fusdStoragePath)\n}\nself.fusdVault = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.nmdldnhIdtlbbe()\nlet totalRepayScaled = LendingPool.cdmebSniwmjehSdbhemeBaillii(borrowerAddress: self.borrowerAddress)\namountRepay = Config.djvxFUiTjebnhIUcdmebS(totalRepayScaled) + 1.0/Config.dmebSvxet\n}\nlet inUnderlyingVault <- self.fusdVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.ailliBwejdl(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.fusdVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\nimport Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction(amount: UFix64) {\nlet bLTVault: &BLT.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet bLTStoragePath = /storage/bLTVault\nif (signer.borrow<&BLT.Vault>(from: bLTStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n}\nself.bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.nmdldnhIdtlbbe()\nlet totalRepayScaled = LendingPool.cdmebSniwmjehSdbhemeBaillii(borrowerAddress: self.borrowerAddress)\namountRepay = Config.djvxFUiTjebnhIUcdmebS(totalRepayScaled) + 1.0/Config.dmebSvxet\n}\nlet inUnderlyingVault <- self.bLTVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.ailliBwejdl(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.bLTVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}"
      },
      "Liquidate": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe87fbdc31260d121\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\nlet flowTokenVault: &FlowToken.Vault\nlet liquidatorAddr: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nself.flowTokenVault  = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.liquidatorAddr = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountLiquidate)\nlet leftVault <- LendingPool.dnecxtkxm(\nliquidator: self.liquidatorAddr,\nborrower: borrower,\npoolCollateralizedToSeize: seizePoolAddr,\nrepayUnderlyingVault: <-inUnderlyingVault\n)\nif leftVault != nil {\nself.flowTokenVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "FUSD": "import FUSD from 0xe223d8a629e49c68\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xf8110b49279777d0\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\nlet fusdVault: &FUSD.Vault\nlet liquidatorAddr: Address\nprepare(signer: AuthAccount) {\nlet fusdStoragePath = /storage/fusdVault\nself.fusdVault  = signer.borrow<&FUSD.Vault>(from: fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.liquidatorAddr = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.fusdVault.withdraw(amount: amountLiquidate)\nlet leftVault <- LendingPool.dnecxtkxm(\nliquidator: self.liquidatorAddr,\nborrower: borrower,\npoolCollateralizedToSeize: seizePoolAddr,\nrepayUnderlyingVault: <-inUnderlyingVault\n)\nif leftVault != nil {\nself.fusdVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x80c056e9db4e71db\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\nlet bLTVault: &BLT.Vault\nlet liquidatorAddr: Address\nprepare(signer: AuthAccount) {\nlet bLTStoragePath = /storage/bLTVault\nself.bLTVault  = signer.borrow<&BLT.Vault>(from: bLTStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nself.liquidatorAddr = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.bLTVault.withdraw(amount: amountLiquidate)\nlet leftVault <- LendingPool.dnecxtkxm(\nliquidator: self.liquidatorAddr,\nborrower: borrower,\npoolCollateralizedToSeize: seizePoolAddr,\nrepayUnderlyingVault: <-inUnderlyingVault\n)\nif leftVault != nil {\nself.bLTVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}"
      },
      "SimpleOracle": {
        "UpdaterUploadFeedData": "import SimpleOracle from 0xb9ea46f9e5fc5504\ntransaction(mmdlccAmiij: Address, enec: UFix64) {\nprepare(updater: AuthAccount) {\nlet updaterRef = updater\n.borrow<&SimpleOracle.OracleUpdateProxy>(from: SimpleOracle.wnePdjelinSldnecjU)\n?? panic(\"Could not borrow reference to updater proxy\")\nupdaterRef.dnecjt(pool: mmdlccAmiij, enec: enec)\n}\n}"
      },
      "Test": {
        "NextBlock": "import Interfaces from 0xbef33bc3b8b3e500\nimport Config from 0xbef33bc3b8b3e500\ntransaction() {\nprepare(signer: AuthAccount) {\nlet poolAddrs = signer.getCapability<&{Interfaces.ComptrollerPublic}>(Config.wnePbxmitPldmmilnjgiC).borrow()!.mndlleMmmAndj()\nfor poolAddr in poolAddrs {\ngetAccount(poolAddr).getCapability<&{Interfaces.PoolPublic}>(Config.wnePbxmitPbxmitPmiiP).borrow()!.nmdldnhIdtlbbe()\n}\n}\nexecute {\n}\n}",
        "MintBLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\nlet bLTStoragePath = /storage/bLTVault\nvar bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath)\nif bLTVault == nil {\nsigner.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n}\nbLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath)\nbLTVault!.deposit(from: <-BLT.test_minter.mintTokens(amount: mintAmount))\n}\n}",
        "MintAll": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\n\nlet bLTStoragePath = /storage/bLTVault\nvar bLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath)\nif bLTVault == nil {\nsigner.save(<-BLT.createEmptyVault(), to: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/bLTReceiver, target: bLTStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/bLTBalance, target: bLTStoragePath)\n}\nbLTVault = signer.borrow<&BLT.Vault>(from: bLTStoragePath)\nbLTVault!.deposit(from: <-BLT.test_minter.mintTokens(amount: mintAmount))\n}\n}\n"
      }
    }
  },
  "Pools": [
    {
      "vaultBalancePath": "flowTokenBalance",
      "poolName": "FlowToken",
      "tokenName": "Flow",
      "marketAddress": "0xe87fbdc31260d121",
      "tokenAddress": "0x7e60df042a9c0868"
    },
    {
      "vaultBalancePath": "fusdBalance",
      "poolName": "FUSD",
      "tokenName": "FUSD",
      "marketAddress": "0xf8110b49279777d0",
      "tokenAddress": "0xe223d8a629e49c68"
    },
    {
      "vaultBalancePath": "bLTBalance",
      "poolName": "BLT",
      "tokenName": "BLT",
      "marketAddress": "0x80c056e9db4e71db",
      "tokenAddress": "0x48adb192e4b081b0"
    }
  ]
}