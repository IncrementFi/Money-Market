{
  "ComptrollerAddress": "0x09068778698543f7",
  "ContractAddress": {
    "LendingConfig": "0x1f52e24bf0814996",
    "LendingError": "0x1f52e24bf0814996",
    "LendingInterfaces": "0x1f52e24bf0814996",
    "LendingComptroller": "0x09068778698543f7",
    "LendingOracle": "0xf2d5e5a95edaf3cc",
    "FungibleToken": "0x9a0766d93b6608b7",
    "FlowToken": "0x7e60df042a9c0868",
    "FUSD": "0xe5b5624186770886",
    "USDC": "0xe5b5624186770886",
    "BLT": "0x48adb192e4b081b0",
    "OracleInterface": "0x2a9b59c3e2b72ee0",
    "OracleConfig": "0x2a9b59c3e2b72ee0",
    "ChainAdmin": "0x09068778698543f7"
  },
  "PoolAddress": {
    "0x16b25c744f20f313": {
      "PoolContract": "LendingPool",
      "PoolName": "FlowToken",
      "LowerPoolName": "flowToken",
      "TokenName": "Flow",
      "VaultBalancePath": "flowTokenBalance",
      "TokenAddress": "0x7e60df042a9c0868",
      "PoolAddress": "0x16b25c744f20f313",
      "Fake": false
    },
    "0x00e63947d624f972": {
      "PoolContract": "LendingPool",
      "PoolName": "FUSD",
      "LowerPoolName": "test_fusd",
      "TokenName": "FUSD",
      "VaultBalancePath": "test_fusdBalance",
      "TokenAddress": "0xe5b5624186770886",
      "PoolAddress": "0x00e63947d624f972",
      "Fake": true
    },
    "0x0bcc0bde1aa1875b": {
      "PoolContract": "LendingPool",
      "PoolName": "USDC",
      "LowerPoolName": "test_usdc",
      "TokenName": "USDC",
      "VaultBalancePath": "test_usdcBalance",
      "TokenAddress": "0xe5b5624186770886",
      "PoolAddress": "0x0bcc0bde1aa1875b",
      "Fake": true
    },
    "0xe481809ac7def9ad": {
      "PoolContract": "LendingPool",
      "PoolName": "BLT",
      "LowerPoolName": "test_blt",
      "TokenName": "BLT",
      "VaultBalancePath": "test_bltBalance",
      "TokenAddress": "0x48adb192e4b081b0",
      "PoolAddress": "0xe481809ac7def9ad",
      "Fake": true
    }
  },
  "Codes": {
    "Scripts": {
      "QueryAllMarkets": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(comptrollerAddr: Address): [Address] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invailid comptroller cap.\",\nerr: LendingError.acweskerf.acwesqerf\n)\n)\nlet poolAddrs = edRldmmilnjgib.mndlleMmmAndj()\nreturn poolAddrs\n}",
      "QueryMarketInfo": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invailid comptroller cap.\",\nerr: LendingError.acweskerf.acwesqerf\n)\n)\nlet poolInfo = edRldmmilnjgib.iehIndlleMndj(poolAddr: poolAddr)\nreturn poolInfo\n}",
      "QueryMarketInfos": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(comptrollerAddr: Address): {Address: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invailid comptroller cap.\",\nerr: LendingError.acweskerf.acwesqerf\n)\n)\nlet poolAddrs = edRldmmilnjgib.mndlleMmmAndj()\nvar poolInfos: {Address: AnyStruct} = {}\nfor poolAddr in poolAddrs {\nlet poolInfo = edRldmmilnjgib.iehIndlleMndj(poolAddr: poolAddr)\npoolInfos.insert(key: poolAddr, poolInfo)\n}\nreturn poolInfos\n}",
      "QueryUserAllPools": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(userAddr: Address, comptrollerAddr: Address): [Address] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invailid comptroller cap.\",\nerr: LendingError.acweskerf.acwesqerf\n)\n)\nlet poolAddrs = edRldmmilnjgib.mndlleMldmUndj(userAddr: userAddr)\nreturn poolAddrs\n}",
      "QueryUserPoolInfo": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(userAddr: Address, poolAddr: Address, comptrollerAddr: Address): {String: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invailid comptroller cap.\",\nerr: LendingError.acweskerf.acwesqerf\n)\n)\nlet userInfo = edRldmmilnjgib.iehIndlleMldmUndj(userAddr: userAddr, poolAddr: poolAddr)\nreturn userInfo\n}",
      "QueryUserPoolInfos": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(userAddr: Address, comptrollerAddr: Address): {Address: AnyStruct} {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invailid comptroller cap.\",\nerr: LendingError.acweskerf.acwesqerf\n)\n)\nvar userInfos: {Address: AnyStruct} = {}\nlet poolAddrs = edRldmmilnjgib.mndlleMldmUndj(userAddr: userAddr)\nfor poolAddr in poolAddrs {\nlet userInfo = edRldmmilnjgib.iehIndlleMldmUndj(userAddr: userAddr, poolAddr: poolAddr)\nuserInfos.insert(key: poolAddr, userInfo)\n}\nreturn userInfos\n}",
      "QueryVaultBalance": "import FungibleToken from 0x9a0766d93b6608b7\npub fun main(userAddr: Address, vaultPath: PublicPath): UFix64 {\nlet vaultBalance = getAccount(userAddr).getCapability<&{FungibleToken.Balance}>(vaultPath)\nif vaultBalance.check() == false || vaultBalance.borrow() == nil {\nreturn 0.0\n}\nreturn vaultBalance.borrow()!.balance\n}",
      "QueryUserPosition": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(userAddr: Address, comptrollerAddr: Address): [String; 3] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invailid comptroller cap.\",\nerr: LendingError.acweskerf.acwesqerf\n)\n)\nlet eaazlsa = edRldmmilnjgib.wnxcxtkxLndlleMmmilCldmUndj(userAddr: userAddr)\nreturn eaazlsa\n}",
      "QueryMarketInterestRateModelParams": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(poolAddr: Address): {String: AnyStruct} {\nlet jeCbxmitPmiij = getAccount(poolAddr).getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.g).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invalid pool capability.\",\nerr: LendingError.acweskerf.acwesperf\n)\n)\nlet interestRateAddress = jeCbxmitPmiij.mmdlccAmdciMdneRnmdldnhIndj()\nlet interestRateModelRef = getAccount(interestRateAddress)\n.getCapability<&{LendingInterfaces.InterestRateModelPublic}>(LendingConfig.a)\n.borrow() ?? panic(\nLendingError.btkpowe (\nmsg: \"Invalid interest rate model capability.\",\nerr: LendingError.acweskerf.acwesrerf\n)\n)\nreturn interestRateModelRef.mgelePmdciMdneRnmdldnhIndj()\n}",
      "QueryMarketBorrowers": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingError from 0x1f52e24bf0814996\npub fun main(comptrollerAddr: Address, poolAddr: Address, from: UInt64, to: UInt64): [Address] {\nlet edRldmmilnjgib = getAccount(comptrollerAddr).getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()\n?? panic(\nLendingError.btkpowe (\nmsg: \"Invailid comptroller cap.\",\nerr: LendingError.acweskerf.acwesqerf\n)\n)\nif from == 0 && to == 0 {\nreturn edRldmmilnjgib.edRbxmitPmiiPndj(poolAddr: poolAddr).nmxLldailliBmiiPndj()\n} else {\nreturn edRldmmilnjgib.edRbxmitPmiiPndj(poolAddr: poolAddr).nmxLcdbxmSldailliBmiiPndj(from: from, to: to)\n}\n}",
      "QuerySimpleOracleFeedLatestResult": "import LendingInterfaces from 0x1f52e24bf0814996\nimport SimpleOracle from 0xSimpleOracle\npub fun main(oracle: Address, pool: Address): [UFix64; 2] {\nlet oracleGetterRef = getAccount(oracle)\n.getCapability<&SimpleOracle.Oracle{LendingInterfaces.OraclePublic}>(SimpleOracle.b)\n.borrow() ?? panic(\"Could not borrow reference to OracleGetter\")\nreturn oracleGetterRef.u(pool: pool)\n}"
    },
    "Transactions": {
      "Deposit": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x16b25c744f20f313\ntransaction(amountDeposit: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountDeposit)\nLendingPool.easclsa(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}",
        "FUSD": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x00e63947d624f972\ntransaction(amountDeposit: UFix64) {\nlet test_fusdVault: &FUSD.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet test_fusdStoragePath = /storage/test_fusdVault\nif (signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/test_fusdReceiver, target: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/test_fusdBalance, target: test_fusdStoragePath)\n}\nself.test_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.test_fusdVault.withdraw(amount: amountDeposit)\nLendingPool.easclsa(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}",
        "USDC": "import USDC from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x0bcc0bde1aa1875b\ntransaction(amountDeposit: UFix64) {\nlet test_usdcVault: &USDC.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet test_usdcStoragePath = /storage/test_usdcVault\nif (signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) == nil) {\nsigner.save(<-USDC.createEmptyVault(), to: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Receiver}>(/public/test_usdcReceiver, target: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Balance}>(/public/test_usdcBalance, target: test_usdcStoragePath)\n}\nself.test_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) ?? panic(\"cannot borrow reference to USDC Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.test_usdcVault.withdraw(amount: amountDeposit)\nLendingPool.easclsa(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe481809ac7def9ad\ntransaction(amountDeposit: UFix64) {\nlet test_bltVault: &BLT.Vault\nlet supplierAddress: Address\nprepare(signer: AuthAccount) {\nlet test_bltStoragePath = /storage/test_bltVault\nif (signer.borrow<&BLT.Vault>(from: test_bltStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/test_bltReceiver, target: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/test_bltBalance, target: test_bltStoragePath)\n}\nself.test_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nself.supplierAddress = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.test_bltVault.withdraw(amount: amountDeposit)\nLendingPool.easclsa(supplierAddr: self.supplierAddress, inUnderlyingVault: <-inUnderlyingVault)\n}\n}"
      },
      "Redeem": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x16b25c744f20f313\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction(easqlsa: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet redeemedVault <- LendingPool.easwlsa(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: easqlsa)\nself.flowTokenVault.deposit(from: <-redeemedVault)\n}\n}",
        "FUSD": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x00e63947d624f972\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction(easqlsa: UFix64) {\nlet test_fusdVault: &FUSD.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_fusdStoragePath = /storage/test_fusdVault\nif (signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/test_fusdReceiver, target: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/test_fusdBalance, target: test_fusdStoragePath)\n}\nself.test_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet redeemedVault <- LendingPool.easwlsa(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: easqlsa)\nself.test_fusdVault.deposit(from: <-redeemedVault)\n}\n}",
        "USDC": "import USDC from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x0bcc0bde1aa1875b\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction(easqlsa: UFix64) {\nlet test_usdcVault: &USDC.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_usdcStoragePath = /storage/test_usdcVault\nif (signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) == nil) {\nsigner.save(<-USDC.createEmptyVault(), to: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Receiver}>(/public/test_usdcReceiver, target: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Balance}>(/public/test_usdcBalance, target: test_usdcStoragePath)\n}\nself.test_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) ?? panic(\"cannot borrow reference to USDC Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet redeemedVault <- LendingPool.easwlsa(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: easqlsa)\nself.test_usdcVault.deposit(from: <-redeemedVault)\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe481809ac7def9ad\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction(easqlsa: UFix64) {\nlet test_bltVault: &BLT.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_bltStoragePath = /storage/test_bltVault\nif (signer.borrow<&BLT.Vault>(from: test_bltStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/test_bltReceiver, target: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/test_bltBalance, target: test_bltStoragePath)\n}\nself.test_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet redeemedVault <- LendingPool.easwlsa(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: easqlsa)\nself.test_bltVault.deposit(from: <-redeemedVault)\n}\n}"
      },
      "RedeemAll": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x16b25c744f20f313\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction() {\nlet flowTokenVault: &FlowToken.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet redeemedVault <- LendingPool.easwlsa(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: UFix64.max)\nself.flowTokenVault.deposit(from: <-redeemedVault)\n}\n}",
        "FUSD": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x00e63947d624f972\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction() {\nlet test_fusdVault: &FUSD.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_fusdStoragePath = /storage/test_fusdVault\nif (signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/test_fusdReceiver, target: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/test_fusdBalance, target: test_fusdStoragePath)\n}\nself.test_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet redeemedVault <- LendingPool.easwlsa(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: UFix64.max)\nself.test_fusdVault.deposit(from: <-redeemedVault)\n}\n}",
        "USDC": "import USDC from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x0bcc0bde1aa1875b\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction() {\nlet test_usdcVault: &USDC.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_usdcStoragePath = /storage/test_usdcVault\nif (signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) == nil) {\nsigner.save(<-USDC.createEmptyVault(), to: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Receiver}>(/public/test_usdcReceiver, target: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Balance}>(/public/test_usdcBalance, target: test_usdcStoragePath)\n}\nself.test_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) ?? panic(\"cannot borrow reference to USDC Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet redeemedVault <- LendingPool.easwlsa(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: UFix64.max)\nself.test_usdcVault.deposit(from: <-redeemedVault)\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe481809ac7def9ad\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction() {\nlet test_bltVault: &BLT.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_bltStoragePath = /storage/test_bltVault\nif (signer.borrow<&BLT.Vault>(from: test_bltStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/test_bltReceiver, target: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/test_bltBalance, target: test_bltStoragePath)\n}\nself.test_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet redeemedVault <- LendingPool.easwlsa(userCertificateCap: self.userCertificateCap, numUnderlyingToRedeem: UFix64.max)\nself.test_bltVault.deposit(from: <-redeemedVault)\n}\n}"
      },
      "Borrow": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x16b25c744f20f313\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction(amountBorrow: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.flowTokenVault.deposit(from: <-borrowVault)\n}\n}",
        "FUSD": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x00e63947d624f972\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction(amountBorrow: UFix64) {\nlet test_fusdVault: &FUSD.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_fusdStoragePath = /storage/test_fusdVault\nif (signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/test_fusdReceiver, target: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/test_fusdBalance, target: test_fusdStoragePath)\n}\nself.test_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.test_fusdVault.deposit(from: <-borrowVault)\n}\n}",
        "USDC": "import USDC from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x0bcc0bde1aa1875b\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction(amountBorrow: UFix64) {\nlet test_usdcVault: &USDC.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_usdcStoragePath = /storage/test_usdcVault\nif (signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) == nil) {\nsigner.save(<-USDC.createEmptyVault(), to: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Receiver}>(/public/test_usdcReceiver, target: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Balance}>(/public/test_usdcBalance, target: test_usdcStoragePath)\n}\nself.test_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) ?? panic(\"cannot borrow reference to USDC Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.test_usdcVault.deposit(from: <-borrowVault)\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe481809ac7def9ad\nimport LendingComptroller from 0x09068778698543f7\nimport LendingConfig from 0x1f52e24bf0814996\nimport LendingInterfaces from 0x1f52e24bf0814996\ntransaction(amountBorrow: UFix64) {\nlet test_bltVault: &BLT.Vault\nlet userCertificateCap: Capability<&{LendingInterfaces.IdentityCertificate}>\nprepare(signer: AuthAccount) {\nlet test_bltStoragePath = /storage/test_bltVault\nif (signer.borrow<&BLT.Vault>(from: test_bltStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/test_bltReceiver, target: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/test_bltBalance, target: test_bltStoragePath)\n}\nself.test_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nif (signer.borrow<&{LendingInterfaces.IdentityCertificate}>(from: LendingConfig.e) == nil) {\ndestroy <-signer.load<@AnyResource>(from: LendingConfig.e)\nlet userCertificate <- LendingComptroller.dnebxexnldCldmUdtmmI()\nsigner.save(<-userCertificate, to: LendingConfig.e)\nsigner.link<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad, target: LendingConfig.e)\n}\nself.userCertificateCap = signer.getCapability<&{LendingInterfaces.IdentityCertificate}>(/private/testadfad)\n}\nexecute {\nlet borrowVault <- LendingPool.borrow(userCertificateCap: self.userCertificateCap, borrowAmount: amountBorrow)\nself.test_bltVault.deposit(from: <-borrowVault)\n}\n}"
      },
      "Repay": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x16b25c744f20f313\nimport LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction(amount: UFix64) {\nlet flowTokenVault: &FlowToken.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.eaaylsa()\nlet totalRepayScaled = LendingPool.easblsa(borrowerAddress: self.borrowerAddress)\namountRepay = LendingConfig.n(totalRepayScaled) + 1.0/LendingConfig.x\n}\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.eaehlsa(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.flowTokenVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "FUSD": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x00e63947d624f972\nimport LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction(amount: UFix64) {\nlet test_fusdVault: &FUSD.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet test_fusdStoragePath = /storage/test_fusdVault\nif (signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/test_fusdReceiver, target: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/test_fusdBalance, target: test_fusdStoragePath)\n}\nself.test_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.eaaylsa()\nlet totalRepayScaled = LendingPool.easblsa(borrowerAddress: self.borrowerAddress)\namountRepay = LendingConfig.n(totalRepayScaled) + 1.0/LendingConfig.x\n}\nlet inUnderlyingVault <- self.test_fusdVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.eaehlsa(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.test_fusdVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "USDC": "import USDC from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x0bcc0bde1aa1875b\nimport LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction(amount: UFix64) {\nlet test_usdcVault: &USDC.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet test_usdcStoragePath = /storage/test_usdcVault\nif (signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) == nil) {\nsigner.save(<-USDC.createEmptyVault(), to: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Receiver}>(/public/test_usdcReceiver, target: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Balance}>(/public/test_usdcBalance, target: test_usdcStoragePath)\n}\nself.test_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) ?? panic(\"cannot borrow reference to USDC Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.eaaylsa()\nlet totalRepayScaled = LendingPool.easblsa(borrowerAddress: self.borrowerAddress)\namountRepay = LendingConfig.n(totalRepayScaled) + 1.0/LendingConfig.x\n}\nlet inUnderlyingVault <- self.test_usdcVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.eaehlsa(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.test_usdcVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe481809ac7def9ad\nimport LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction(amount: UFix64) {\nlet test_bltVault: &BLT.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet test_bltStoragePath = /storage/test_bltVault\nif (signer.borrow<&BLT.Vault>(from: test_bltStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/test_bltReceiver, target: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/test_bltBalance, target: test_bltStoragePath)\n}\nself.test_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nvar amountRepay = amount\nif amountRepay == UFix64.max {\nLendingPool.eaaylsa()\nlet totalRepayScaled = LendingPool.easblsa(borrowerAddress: self.borrowerAddress)\namountRepay = LendingConfig.n(totalRepayScaled) + 1.0/LendingConfig.x\n}\nlet inUnderlyingVault <- self.test_bltVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.eaehlsa(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.test_bltVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}"
      },
      "RepayAll": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x16b25c744f20f313\nimport LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction() {\nlet flowTokenVault: &FlowToken.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nif (signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) == nil) {\nsigner.save(<-FlowToken.createEmptyVault(), to: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver, target: flowTokenStoragePath)\nsigner.link<&FlowToken.Vault{FungibleToken.Balance}>(/public/flowTokenBalance, target: flowTokenStoragePath)\n}\nself.flowTokenVault = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nLendingPool.eaaylsa()\nlet totalRepayScaled = LendingPool.easblsa(borrowerAddress: self.borrowerAddress)\nvar amountRepay = LendingConfig.n(totalRepayScaled) + 1.0/LendingConfig.x\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.eaehlsa(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.flowTokenVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "FUSD": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x00e63947d624f972\nimport LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction() {\nlet test_fusdVault: &FUSD.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet test_fusdStoragePath = /storage/test_fusdVault\nif (signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) == nil) {\nsigner.save(<-FUSD.createEmptyVault(), to: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/test_fusdReceiver, target: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/test_fusdBalance, target: test_fusdStoragePath)\n}\nself.test_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nLendingPool.eaaylsa()\nlet totalRepayScaled = LendingPool.easblsa(borrowerAddress: self.borrowerAddress)\nvar amountRepay = LendingConfig.n(totalRepayScaled) + 1.0/LendingConfig.x\nlet inUnderlyingVault <- self.test_fusdVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.eaehlsa(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.test_fusdVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "USDC": "import USDC from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x0bcc0bde1aa1875b\nimport LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction() {\nlet test_usdcVault: &USDC.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet test_usdcStoragePath = /storage/test_usdcVault\nif (signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) == nil) {\nsigner.save(<-USDC.createEmptyVault(), to: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Receiver}>(/public/test_usdcReceiver, target: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Balance}>(/public/test_usdcBalance, target: test_usdcStoragePath)\n}\nself.test_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) ?? panic(\"cannot borrow reference to USDC Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nLendingPool.eaaylsa()\nlet totalRepayScaled = LendingPool.easblsa(borrowerAddress: self.borrowerAddress)\nvar amountRepay = LendingConfig.n(totalRepayScaled) + 1.0/LendingConfig.x\nlet inUnderlyingVault <- self.test_usdcVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.eaehlsa(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.test_usdcVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe481809ac7def9ad\nimport LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction() {\nlet test_bltVault: &BLT.Vault\nlet borrowerAddress: Address\nprepare(signer: AuthAccount) {\nlet test_bltStoragePath = /storage/test_bltVault\nif (signer.borrow<&BLT.Vault>(from: test_bltStoragePath) == nil) {\nsigner.save(<-BLT.createEmptyVault(), to: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/test_bltReceiver, target: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/test_bltBalance, target: test_bltStoragePath)\n}\nself.test_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nself.borrowerAddress = signer.address\n}\nexecute {\nLendingPool.eaaylsa()\nlet totalRepayScaled = LendingPool.easblsa(borrowerAddress: self.borrowerAddress)\nvar amountRepay = LendingConfig.n(totalRepayScaled) + 1.0/LendingConfig.x\nlet inUnderlyingVault <- self.test_bltVault.withdraw(amount: amountRepay)\nlet leftVault <- LendingPool.eaehlsa(borrower: self.borrowerAddress, repayUnderlyingVault: <-inUnderlyingVault)\nif leftVault != nil {\nself.test_bltVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}"
      },
      "Liquidate": {
        "FlowToken": "import FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x16b25c744f20f313\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\nlet flowTokenVault: &FlowToken.Vault\nlet liquidatorAddr: Address\nprepare(signer: AuthAccount) {\nlet flowTokenStoragePath = /storage/flowTokenVault\nself.flowTokenVault  = signer.borrow<&FlowToken.Vault>(from: flowTokenStoragePath) ?? panic(\"cannot borrow reference to FlowToken Vault\")\nself.liquidatorAddr = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.flowTokenVault.withdraw(amount: amountLiquidate)\nlet leftVault <- LendingPool.eaeklsa(\nliquidator: self.liquidatorAddr,\nborrower: borrower,\npoolCollateralizedToSeize: seizePoolAddr,\nrepayUnderlyingVault: <-inUnderlyingVault\n)\nif leftVault != nil {\nself.flowTokenVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "FUSD": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x00e63947d624f972\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\nlet test_fusdVault: &FUSD.Vault\nlet liquidatorAddr: Address\nprepare(signer: AuthAccount) {\nlet test_fusdStoragePath = /storage/test_fusdVault\nself.test_fusdVault  = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath) ?? panic(\"cannot borrow reference to FUSD Vault\")\nself.liquidatorAddr = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.test_fusdVault.withdraw(amount: amountLiquidate)\nlet leftVault <- LendingPool.eaeklsa(\nliquidator: self.liquidatorAddr,\nborrower: borrower,\npoolCollateralizedToSeize: seizePoolAddr,\nrepayUnderlyingVault: <-inUnderlyingVault\n)\nif leftVault != nil {\nself.test_fusdVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "USDC": "import USDC from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0x0bcc0bde1aa1875b\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\nlet test_usdcVault: &USDC.Vault\nlet liquidatorAddr: Address\nprepare(signer: AuthAccount) {\nlet test_usdcStoragePath = /storage/test_usdcVault\nself.test_usdcVault  = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath) ?? panic(\"cannot borrow reference to USDC Vault\")\nself.liquidatorAddr = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.test_usdcVault.withdraw(amount: amountLiquidate)\nlet leftVault <- LendingPool.eaeklsa(\nliquidator: self.liquidatorAddr,\nborrower: borrower,\npoolCollateralizedToSeize: seizePoolAddr,\nrepayUnderlyingVault: <-inUnderlyingVault\n)\nif leftVault != nil {\nself.test_usdcVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}",
        "BLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\nimport LendingPool from 0xe481809ac7def9ad\ntransaction(amountLiquidate: UFix64, borrower: Address, seizePoolAddr: Address) {\nlet test_bltVault: &BLT.Vault\nlet liquidatorAddr: Address\nprepare(signer: AuthAccount) {\nlet test_bltStoragePath = /storage/test_bltVault\nself.test_bltVault  = signer.borrow<&BLT.Vault>(from: test_bltStoragePath) ?? panic(\"cannot borrow reference to BLT Vault\")\nself.liquidatorAddr = signer.address\n}\nexecute {\nlet inUnderlyingVault <- self.test_bltVault.withdraw(amount: amountLiquidate)\nlet leftVault <- LendingPool.eaeklsa(\nliquidator: self.liquidatorAddr,\nborrower: borrower,\npoolCollateralizedToSeize: seizePoolAddr,\nrepayUnderlyingVault: <-inUnderlyingVault\n)\nif leftVault != nil {\nself.test_bltVault.deposit(from: <-leftVault!)\n} else {\ndestroy leftVault\n}\n}\n}"
      },
      "SimpleOracle": {
        "UpdaterUploadFeedData": "import SimpleOracle from 0xSimpleOracle\ntransaction(btlpowe: Address, enec: UFix64) {\nprepare(updater: AuthAccount) {\nlet updaterRef = updater\n.borrow<&SimpleOracle.OracleUpdateProxy>(from: SimpleOracle.wnePdjelinSldnecjU)\n?? panic(\"Could not borrow reference to updater proxy\")\nupdaterRef.dnecjt(pool: btlpowe, enec: enec)\n}\n}"
      },
      "Test": {
        "NextBlock": "import LendingInterfaces from 0x1f52e24bf0814996\nimport LendingConfig from 0x1f52e24bf0814996\ntransaction() {\nprepare(signer: AuthAccount) {\nlet poolAddrs = signer.getCapability<&{LendingInterfaces.ComptrollerPublic}>(LendingConfig.d).borrow()!.mndlleMmmAndj()\nfor poolAddr in poolAddrs {\ngetAccount(poolAddr).getCapability<&{LendingInterfaces.PoolPublic}>(LendingConfig.g).borrow()!.eaaylsa()\n}\n}\nexecute {\n}\n}",
        "MintFUSD": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\nlet test_fusdStoragePath = /storage/test_fusdVault\nvar test_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath)\nif test_fusdVault == nil {\nsigner.save(<-FUSD.createEmptyVault(), to: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/test_fusdReceiver, target: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/test_fusdBalance, target: test_fusdStoragePath)\n}\ntest_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath)\ntest_fusdVault!.deposit(from: <-FUSD.test_minter.mintTokens(amount: mintAmount))\n}\n}",
        "MintUSDC": "import USDC from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\nlet test_usdcStoragePath = /storage/test_usdcVault\nvar test_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath)\nif test_usdcVault == nil {\nsigner.save(<-USDC.createEmptyVault(), to: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Receiver}>(/public/test_usdcReceiver, target: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Balance}>(/public/test_usdcBalance, target: test_usdcStoragePath)\n}\ntest_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath)\ntest_usdcVault!.deposit(from: <-USDC.test_minter.mintTokens(amount: mintAmount))\n}\n}",
        "MintBLT": "import BLT from 0x48adb192e4b081b0\nimport FungibleToken from 0x9a0766d93b6608b7\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\nlet test_bltStoragePath = /storage/test_bltVault\nvar test_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath)\nif test_bltVault == nil {\nsigner.save(<-BLT.createEmptyVault(), to: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/test_bltReceiver, target: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/test_bltBalance, target: test_bltStoragePath)\n}\ntest_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath)\ntest_bltVault!.deposit(from: <-BLT.test_minter.mintTokens(amount: mintAmount))\n}\n}",
        "MintAll": "import FUSD from 0xe5b5624186770886\nimport FungibleToken from 0x9a0766d93b6608b7\nimport USDC from 0xe5b5624186770886\nimport BLT from 0x48adb192e4b081b0\ntransaction(mintAmount: UFix64) {\nprepare(signer: AuthAccount) {\n\nlet test_fusdStoragePath = /storage/test_fusdVault\nvar test_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath)\nif test_fusdVault == nil {\nsigner.save(<-FUSD.createEmptyVault(), to: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/test_fusdReceiver, target: test_fusdStoragePath)\nsigner.link<&FUSD.Vault{FungibleToken.Balance}>(/public/test_fusdBalance, target: test_fusdStoragePath)\n}\ntest_fusdVault = signer.borrow<&FUSD.Vault>(from: test_fusdStoragePath)\ntest_fusdVault!.deposit(from: <-FUSD.test_minter.mintTokens(amount: mintAmount))\n\nlet test_usdcStoragePath = /storage/test_usdcVault\nvar test_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath)\nif test_usdcVault == nil {\nsigner.save(<-USDC.createEmptyVault(), to: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Receiver}>(/public/test_usdcReceiver, target: test_usdcStoragePath)\nsigner.link<&USDC.Vault{FungibleToken.Balance}>(/public/test_usdcBalance, target: test_usdcStoragePath)\n}\ntest_usdcVault = signer.borrow<&USDC.Vault>(from: test_usdcStoragePath)\ntest_usdcVault!.deposit(from: <-USDC.test_minter.mintTokens(amount: mintAmount))\n\nlet test_bltStoragePath = /storage/test_bltVault\nvar test_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath)\nif test_bltVault == nil {\nsigner.save(<-BLT.createEmptyVault(), to: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Receiver}>(/public/test_bltReceiver, target: test_bltStoragePath)\nsigner.link<&BLT.Vault{FungibleToken.Balance}>(/public/test_bltBalance, target: test_bltStoragePath)\n}\ntest_bltVault = signer.borrow<&BLT.Vault>(from: test_bltStoragePath)\ntest_bltVault!.deposit(from: <-BLT.test_minter.mintTokens(amount: mintAmount))\n}\n}\n"
      }
    }
  },
  "Pools": [
    {
      "vaultBalancePath": "flowTokenBalance",
      "poolName": "FlowToken",
      "tokenName": "Flow",
      "marketAddress": "0x16b25c744f20f313",
      "tokenAddress": "0x7e60df042a9c0868"
    },
    {
      "vaultBalancePath": "test_fusdBalance",
      "poolName": "FUSD",
      "tokenName": "FUSD",
      "marketAddress": "0x00e63947d624f972",
      "tokenAddress": "0xe5b5624186770886"
    },
    {
      "vaultBalancePath": "test_usdcBalance",
      "poolName": "USDC",
      "tokenName": "USDC",
      "marketAddress": "0x0bcc0bde1aa1875b",
      "tokenAddress": "0xe5b5624186770886"
    },
    {
      "vaultBalancePath": "test_bltBalance",
      "poolName": "BLT",
      "tokenName": "BLT",
      "marketAddress": "0xe481809ac7def9ad",
      "tokenAddress": "0x48adb192e4b081b0"
    }
  ]
}